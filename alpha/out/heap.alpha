// Generated by C-Alpha Compiler
// Target: Alpha_TUI Assembly

// Layout declaration: __import_io_calpha
// DEBUG: Processing layout declaration for __import_io_calpha
// DEBUG: Setting up layout '__import_io_calpha' with 1 members
// DEBUG: Found layout symbol with FQDN: __import_io_calpha
// DEBUG: Layout is in namespace: global
// DEBUG: Layout __import_io_calpha member '_dummy' at offset 0

// Layout declaration: __import_bitwise_calpha
// DEBUG: Processing layout declaration for __import_bitwise_calpha
// DEBUG: Setting up layout '__import_bitwise_calpha' with 1 members
// DEBUG: Found layout symbol with FQDN: __import_bitwise_calpha
// DEBUG: Layout is in namespace: global
// DEBUG: Layout __import_bitwise_calpha member '_dummy' at offset 0

// Namespace: bit
// Function declaration: get_last_bit

namespace_bit_get_last_bit:
// DEBUG: Function get_last_bit starts with stack depth: 1
pop // Get parameter a
// DEBUG: Stack depth after pop: 0
p(1) := a0 // Store parameter a
// DEBUG: Parameter a stored at address 1
// Return statement
// DEBUG: Loading variable namespace_bit_function_get_last_bit_a from address 1
a0 := p(1) // Load a
push //  variable a
// DEBUG: Stack depth after push: 1
a0 := 2
push // Literal value2
// DEBUG: Stack depth after push: 2
stack% // Binary operation
return // Return from function
// Function get_last_bit ends without explicit return
// Function declaration: BITWISE_AND

namespace_bit_BITWISE_AND:
// DEBUG: Function BITWISE_AND starts with stack depth: 2
pop // Get parameter a
// DEBUG: Stack depth after pop: 1
p(2) := a0 // Store parameter a
// DEBUG: Parameter a stored at address 2
pop // Get parameter b
// DEBUG: Stack depth after pop: 0
p(3) := a0 // Store parameter b
// DEBUG: Parameter b stored at address 3
a0 := 64
push // Literal value64
// DEBUG: Stack depth after push: 1
pop // Initialize steps
// DEBUG: Stack depth after pop: 0
p(4) := a0 // Store namespace_bit_function_BITWISE_AND_block_steps
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Initialize result
// DEBUG: Stack depth after pop: 0
p(5) := a0 // Store namespace_bit_function_BITWISE_AND_block_result
a0 := 1
push // Literal value1
// DEBUG: Stack depth after push: 1
pop // Initialize place
// DEBUG: Stack depth after pop: 0
p(6) := a0 // Store namespace_bit_function_BITWISE_AND_block_place
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Initialize and
// DEBUG: Stack depth after pop: 0
p(7) := a0 // Store namespace_bit_function_BITWISE_AND_block_and
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Initialize bitA
// DEBUG: Stack depth after pop: 0
p(8) := a0 // Store namespace_bit_function_BITWISE_AND_block_bitA
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Initialize bitB
// DEBUG: Stack depth after pop: 0
p(9) := a0 // Store namespace_bit_function_BITWISE_AND_block_bitB
// While statement
loop1:
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_steps from address 4
a0 := p(4) // Load steps
push //  variable steps
// DEBUG: Stack depth after push: 1
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Get right operand
// DEBUG: Stack depth after pop: 1
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 0
if a0 > a1 then goto true3 // Jump if greater than
a0 := 0 // Comparison result: false
goto cmp_end4
true3:
a0 := 1 // Comparison result: true
cmp_end4:
push //  comparison result
// DEBUG: Stack depth after push: 1
pop // Get condition result
// DEBUG: Stack depth after pop: 0
a1 := 0
if a0 == a1 then goto endloop2 // Jump to end if condition is false
// If statement
// DEBUG: Loading variable namespace_bit_function_get_last_bit_a from address 2
a0 := p(2) // Load a
push //  variable a
// DEBUG: Stack depth after push: 1
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Get right operand
// DEBUG: Stack depth after pop: 1
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 0
if a0 == a1 then goto true7 // Jump if equal
a0 := 0 // Comparison result: false
goto cmp_end8
true7:
a0 := 1 // Comparison result: true
cmp_end8:
push //  comparison result
// DEBUG: Stack depth after push: 1
pop // Get condition result
// DEBUG: Stack depth after pop: 0
a1 := 0
if a0 == a1 then goto else5 // Jump to else if condition is false
// If statement
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_b from address 3
a0 := p(3) // Load b
push //  variable b
// DEBUG: Stack depth after push: 1
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Get right operand
// DEBUG: Stack depth after pop: 1
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 0
if a0 == a1 then goto true11 // Jump if equal
a0 := 0 // Comparison result: false
goto cmp_end12
true11:
a0 := 1 // Comparison result: true
cmp_end12:
push //  comparison result
// DEBUG: Stack depth after push: 1
pop // Get condition result
// DEBUG: Stack depth after pop: 0
a1 := 0
if a0 == a1 then goto else9 // Jump to else if condition is false
// Return statement
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_result from address 5
a0 := p(5) // Load result
push //  variable result
// DEBUG: Stack depth after push: 1
return // Return from function
goto endif10 // Jump to end
else9:
endif10:

goto endif6 // Jump to end
else5:
endif6:

// Assignment
// Function call: get_last_bit
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_bit_function_get_last_bit_a from address 2
a0 := p(2) // Load a
push //  variable a
// DEBUG: Stack depth after push: 2
call namespace_bit_get_last_bit // Function call
// DEBUG: Function call completed - return value is on stack
pop // Assign to bitA
// DEBUG: Stack depth after pop: 1
p(8) := a0 // Store namespace_bit_function_BITWISE_AND_block_bitA

// Assignment
// Function call: get_last_bit
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_b from address 3
a0 := p(3) // Load b
push //  variable b
// DEBUG: Stack depth after push: 2
call namespace_bit_get_last_bit // Function call
// DEBUG: Function call completed - return value is on stack
pop // Assign to bitB
// DEBUG: Stack depth after pop: 1
p(9) := a0 // Store namespace_bit_function_BITWISE_AND_block_bitB

// Assignment
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_bitA from address 8
a0 := p(8) // Load bitA
push //  variable bitA
// DEBUG: Stack depth after push: 2
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_bitB from address 9
a0 := p(9) // Load bitB
push //  variable bitB
// DEBUG: Stack depth after push: 3
stack+ // Binary operation
a0 := 2
push // Literal value2
// DEBUG: Stack depth after push: 4
pop // Get right operand
// DEBUG: Stack depth after pop: 3
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 2
if a0 == a1 then goto true13 // Jump if equal
a0 := 0 // Comparison result: false
goto cmp_end14
true13:
a0 := 1 // Comparison result: true
cmp_end14:
push //  comparison result
// DEBUG: Stack depth after push: 3
pop // Assign to and
// DEBUG: Stack depth after pop: 2
p(7) := a0 // Store namespace_bit_function_BITWISE_AND_block_and

// Assignment
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_result from address 5
a0 := p(5) // Load result
push //  variable result
// DEBUG: Stack depth after push: 3
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_and from address 7
a0 := p(7) // Load and
push //  variable and
// DEBUG: Stack depth after push: 4
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_place from address 6
a0 := p(6) // Load place
push //  variable place
// DEBUG: Stack depth after push: 5
stack* // Binary operation
stack+ // Binary operation
pop // Assign to result
// DEBUG: Stack depth after pop: 4
p(5) := a0 // Store namespace_bit_function_BITWISE_AND_block_result

// Assignment
// DEBUG: Loading variable namespace_bit_function_get_last_bit_a from address 2
a0 := p(2) // Load a
push //  variable a
// DEBUG: Stack depth after push: 5
a0 := 2
push // Literal value2
// DEBUG: Stack depth after push: 6
stack/ // Binary operation
pop // Assign to a
// DEBUG: Stack depth after pop: 5
p(2) := a0 // Store namespace_bit_function_get_last_bit_a

// Assignment
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_b from address 3
a0 := p(3) // Load b
push //  variable b
// DEBUG: Stack depth after push: 6
a0 := 2
push // Literal value2
// DEBUG: Stack depth after push: 7
stack/ // Binary operation
pop // Assign to b
// DEBUG: Stack depth after pop: 6
p(3) := a0 // Store namespace_bit_function_BITWISE_AND_b

// Assignment
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_place from address 6
a0 := p(6) // Load place
push //  variable place
// DEBUG: Stack depth after push: 7
a0 := 2
push // Literal value2
// DEBUG: Stack depth after push: 8
stack* // Binary operation
pop // Assign to place
// DEBUG: Stack depth after pop: 7
p(6) := a0 // Store namespace_bit_function_BITWISE_AND_block_place

// Assignment
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_steps from address 4
a0 := p(4) // Load steps
push //  variable steps
// DEBUG: Stack depth after push: 8
a0 := 1
push // Literal value1
// DEBUG: Stack depth after push: 9
stack- // Binary operation
pop // Assign to steps
// DEBUG: Stack depth after pop: 8
p(4) := a0 // Store namespace_bit_function_BITWISE_AND_block_steps

goto loop1 // Jump back to loop start
endloop2:

// Return statement
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_result from address 5
a0 := p(5) // Load result
push //  variable result
// DEBUG: Stack depth after push: 9
return // Return from function
// Function BITWISE_AND ends without explicit return
// Function declaration: BITWISE_OR

namespace_bit_BITWISE_OR:
// DEBUG: Function BITWISE_OR starts with stack depth: 2
pop // Get parameter a
// DEBUG: Stack depth after pop: 1
p(10) := a0 // Store parameter a
// DEBUG: Parameter a stored at address 10
pop // Get parameter b
// DEBUG: Stack depth after pop: 0
p(11) := a0 // Store parameter b
// DEBUG: Parameter b stored at address 11
a0 := 64
push // Literal value64
// DEBUG: Stack depth after push: 1
pop // Initialize steps
// DEBUG: Stack depth after pop: 0
p(12) := a0 // Store namespace_bit_function_BITWISE_AND_block_steps
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Initialize result
// DEBUG: Stack depth after pop: 0
p(13) := a0 // Store namespace_bit_function_BITWISE_AND_block_result
a0 := 1
push // Literal value1
// DEBUG: Stack depth after push: 1
pop // Initialize place
// DEBUG: Stack depth after pop: 0
p(14) := a0 // Store namespace_bit_function_BITWISE_AND_block_place
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Initialize or
// DEBUG: Stack depth after pop: 0
p(15) := a0 // Store namespace_bit_function_BITWISE_OR_block_or
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Initialize bitA
// DEBUG: Stack depth after pop: 0
p(16) := a0 // Store namespace_bit_function_BITWISE_AND_block_bitA
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Initialize bitB
// DEBUG: Stack depth after pop: 0
p(17) := a0 // Store namespace_bit_function_BITWISE_AND_block_bitB
// While statement
loop15:
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_steps from address 12
a0 := p(12) // Load steps
push //  variable steps
// DEBUG: Stack depth after push: 1
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Get right operand
// DEBUG: Stack depth after pop: 1
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 0
if a0 > a1 then goto true17 // Jump if greater than
a0 := 0 // Comparison result: false
goto cmp_end18
true17:
a0 := 1 // Comparison result: true
cmp_end18:
push //  comparison result
// DEBUG: Stack depth after push: 1
pop // Get condition result
// DEBUG: Stack depth after pop: 0
a1 := 0
if a0 == a1 then goto endloop16 // Jump to end if condition is false
// If statement
// DEBUG: Loading variable namespace_bit_function_get_last_bit_a from address 10
a0 := p(10) // Load a
push //  variable a
// DEBUG: Stack depth after push: 1
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Get right operand
// DEBUG: Stack depth after pop: 1
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 0
if a0 == a1 then goto true21 // Jump if equal
a0 := 0 // Comparison result: false
goto cmp_end22
true21:
a0 := 1 // Comparison result: true
cmp_end22:
push //  comparison result
// DEBUG: Stack depth after push: 1
pop // Get condition result
// DEBUG: Stack depth after pop: 0
a1 := 0
if a0 == a1 then goto else19 // Jump to else if condition is false
// If statement
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_b from address 11
a0 := p(11) // Load b
push //  variable b
// DEBUG: Stack depth after push: 1
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Get right operand
// DEBUG: Stack depth after pop: 1
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 0
if a0 == a1 then goto true25 // Jump if equal
a0 := 0 // Comparison result: false
goto cmp_end26
true25:
a0 := 1 // Comparison result: true
cmp_end26:
push //  comparison result
// DEBUG: Stack depth after push: 1
pop // Get condition result
// DEBUG: Stack depth after pop: 0
a1 := 0
if a0 == a1 then goto else23 // Jump to else if condition is false
// Return statement
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_result from address 13
a0 := p(13) // Load result
push //  variable result
// DEBUG: Stack depth after push: 1
return // Return from function
goto endif24 // Jump to end
else23:
endif24:

goto endif20 // Jump to end
else19:
endif20:

// Assignment
// Function call: get_last_bit
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_bit_function_get_last_bit_a from address 10
a0 := p(10) // Load a
push //  variable a
// DEBUG: Stack depth after push: 2
call namespace_bit_get_last_bit // Function call
// DEBUG: Function call completed - return value is on stack
pop // Assign to bitA
// DEBUG: Stack depth after pop: 1
p(16) := a0 // Store namespace_bit_function_BITWISE_AND_block_bitA

// Assignment
// Function call: get_last_bit
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_b from address 11
a0 := p(11) // Load b
push //  variable b
// DEBUG: Stack depth after push: 2
call namespace_bit_get_last_bit // Function call
// DEBUG: Function call completed - return value is on stack
pop // Assign to bitB
// DEBUG: Stack depth after pop: 1
p(17) := a0 // Store namespace_bit_function_BITWISE_AND_block_bitB

// Assignment
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_bitA from address 16
a0 := p(16) // Load bitA
push //  variable bitA
// DEBUG: Stack depth after push: 2
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_bitB from address 17
a0 := p(17) // Load bitB
push //  variable bitB
// DEBUG: Stack depth after push: 3
stack+ // Binary operation
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 4
pop // Get right operand
// DEBUG: Stack depth after pop: 3
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 2
if a0 > a1 then goto true27 // Jump if greater than
a0 := 0 // Comparison result: false
goto cmp_end28
true27:
a0 := 1 // Comparison result: true
cmp_end28:
push //  comparison result
// DEBUG: Stack depth after push: 3
pop // Assign to or
// DEBUG: Stack depth after pop: 2
p(15) := a0 // Store namespace_bit_function_BITWISE_OR_block_or

// Assignment
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_result from address 13
a0 := p(13) // Load result
push //  variable result
// DEBUG: Stack depth after push: 3
// DEBUG: Loading variable namespace_bit_function_BITWISE_OR_block_or from address 15
a0 := p(15) // Load or
push //  variable or
// DEBUG: Stack depth after push: 4
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_place from address 14
a0 := p(14) // Load place
push //  variable place
// DEBUG: Stack depth after push: 5
stack* // Binary operation
stack+ // Binary operation
pop // Assign to result
// DEBUG: Stack depth after pop: 4
p(13) := a0 // Store namespace_bit_function_BITWISE_AND_block_result

// Assignment
// DEBUG: Loading variable namespace_bit_function_get_last_bit_a from address 10
a0 := p(10) // Load a
push //  variable a
// DEBUG: Stack depth after push: 5
a0 := 2
push // Literal value2
// DEBUG: Stack depth after push: 6
stack/ // Binary operation
pop // Assign to a
// DEBUG: Stack depth after pop: 5
p(10) := a0 // Store namespace_bit_function_get_last_bit_a

// Assignment
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_b from address 11
a0 := p(11) // Load b
push //  variable b
// DEBUG: Stack depth after push: 6
a0 := 2
push // Literal value2
// DEBUG: Stack depth after push: 7
stack/ // Binary operation
pop // Assign to b
// DEBUG: Stack depth after pop: 6
p(11) := a0 // Store namespace_bit_function_BITWISE_AND_b

// Assignment
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_place from address 14
a0 := p(14) // Load place
push //  variable place
// DEBUG: Stack depth after push: 7
a0 := 2
push // Literal value2
// DEBUG: Stack depth after push: 8
stack* // Binary operation
pop // Assign to place
// DEBUG: Stack depth after pop: 7
p(14) := a0 // Store namespace_bit_function_BITWISE_AND_block_place

// Assignment
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_steps from address 12
a0 := p(12) // Load steps
push //  variable steps
// DEBUG: Stack depth after push: 8
a0 := 1
push // Literal value1
// DEBUG: Stack depth after push: 9
stack- // Binary operation
pop // Assign to steps
// DEBUG: Stack depth after pop: 8
p(12) := a0 // Store namespace_bit_function_BITWISE_AND_block_steps

goto loop15 // Jump back to loop start
endloop16:

// Return statement
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_result from address 13
a0 := p(13) // Load result
push //  variable result
// DEBUG: Stack depth after push: 9
return // Return from function
// Function BITWISE_OR ends without explicit return
// Function declaration: BITWISE_XOR

namespace_bit_BITWISE_XOR:
// DEBUG: Function BITWISE_XOR starts with stack depth: 2
pop // Get parameter a
// DEBUG: Stack depth after pop: 1
p(18) := a0 // Store parameter a
// DEBUG: Parameter a stored at address 18
pop // Get parameter b
// DEBUG: Stack depth after pop: 0
p(19) := a0 // Store parameter b
// DEBUG: Parameter b stored at address 19
a0 := 64
push // Literal value64
// DEBUG: Stack depth after push: 1
pop // Initialize steps
// DEBUG: Stack depth after pop: 0
p(20) := a0 // Store namespace_bit_function_BITWISE_AND_block_steps
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Initialize result
// DEBUG: Stack depth after pop: 0
p(21) := a0 // Store namespace_bit_function_BITWISE_AND_block_result
a0 := 1
push // Literal value1
// DEBUG: Stack depth after push: 1
pop // Initialize place
// DEBUG: Stack depth after pop: 0
p(22) := a0 // Store namespace_bit_function_BITWISE_AND_block_place
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Initialize xor
// DEBUG: Stack depth after pop: 0
p(23) := a0 // Store namespace_bit_function_BITWISE_XOR_block_xor
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Initialize bitA
// DEBUG: Stack depth after pop: 0
p(24) := a0 // Store namespace_bit_function_BITWISE_AND_block_bitA
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Initialize bitB
// DEBUG: Stack depth after pop: 0
p(25) := a0 // Store namespace_bit_function_BITWISE_AND_block_bitB
// While statement
loop29:
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_steps from address 20
a0 := p(20) // Load steps
push //  variable steps
// DEBUG: Stack depth after push: 1
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Get right operand
// DEBUG: Stack depth after pop: 1
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 0
if a0 > a1 then goto true31 // Jump if greater than
a0 := 0 // Comparison result: false
goto cmp_end32
true31:
a0 := 1 // Comparison result: true
cmp_end32:
push //  comparison result
// DEBUG: Stack depth after push: 1
pop // Get condition result
// DEBUG: Stack depth after pop: 0
a1 := 0
if a0 == a1 then goto endloop30 // Jump to end if condition is false
// If statement
// DEBUG: Loading variable namespace_bit_function_get_last_bit_a from address 18
a0 := p(18) // Load a
push //  variable a
// DEBUG: Stack depth after push: 1
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Get right operand
// DEBUG: Stack depth after pop: 1
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 0
if a0 == a1 then goto true35 // Jump if equal
a0 := 0 // Comparison result: false
goto cmp_end36
true35:
a0 := 1 // Comparison result: true
cmp_end36:
push //  comparison result
// DEBUG: Stack depth after push: 1
pop // Get condition result
// DEBUG: Stack depth after pop: 0
a1 := 0
if a0 == a1 then goto else33 // Jump to else if condition is false
// If statement
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_b from address 19
a0 := p(19) // Load b
push //  variable b
// DEBUG: Stack depth after push: 1
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Get right operand
// DEBUG: Stack depth after pop: 1
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 0
if a0 == a1 then goto true39 // Jump if equal
a0 := 0 // Comparison result: false
goto cmp_end40
true39:
a0 := 1 // Comparison result: true
cmp_end40:
push //  comparison result
// DEBUG: Stack depth after push: 1
pop // Get condition result
// DEBUG: Stack depth after pop: 0
a1 := 0
if a0 == a1 then goto else37 // Jump to else if condition is false
// Return statement
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_result from address 21
a0 := p(21) // Load result
push //  variable result
// DEBUG: Stack depth after push: 1
return // Return from function
goto endif38 // Jump to end
else37:
endif38:

goto endif34 // Jump to end
else33:
endif34:

// Assignment
// Function call: get_last_bit
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_bit_function_get_last_bit_a from address 18
a0 := p(18) // Load a
push //  variable a
// DEBUG: Stack depth after push: 2
call namespace_bit_get_last_bit // Function call
// DEBUG: Function call completed - return value is on stack
pop // Assign to bitA
// DEBUG: Stack depth after pop: 1
p(24) := a0 // Store namespace_bit_function_BITWISE_AND_block_bitA

// Assignment
// Function call: get_last_bit
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_b from address 19
a0 := p(19) // Load b
push //  variable b
// DEBUG: Stack depth after push: 2
call namespace_bit_get_last_bit // Function call
// DEBUG: Function call completed - return value is on stack
pop // Assign to bitB
// DEBUG: Stack depth after pop: 1
p(25) := a0 // Store namespace_bit_function_BITWISE_AND_block_bitB

// Assignment
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_bitA from address 24
a0 := p(24) // Load bitA
push //  variable bitA
// DEBUG: Stack depth after push: 2
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_bitB from address 25
a0 := p(25) // Load bitB
push //  variable bitB
// DEBUG: Stack depth after push: 3
stack+ // Binary operation
a0 := 2
push // Literal value2
// DEBUG: Stack depth after push: 4
stack% // Binary operation
pop // Assign to xor
// DEBUG: Stack depth after pop: 3
p(23) := a0 // Store namespace_bit_function_BITWISE_XOR_block_xor

// Assignment
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_result from address 21
a0 := p(21) // Load result
push //  variable result
// DEBUG: Stack depth after push: 4
// DEBUG: Loading variable namespace_bit_function_BITWISE_XOR_block_xor from address 23
a0 := p(23) // Load xor
push //  variable xor
// DEBUG: Stack depth after push: 5
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_place from address 22
a0 := p(22) // Load place
push //  variable place
// DEBUG: Stack depth after push: 6
stack* // Binary operation
stack+ // Binary operation
pop // Assign to result
// DEBUG: Stack depth after pop: 5
p(21) := a0 // Store namespace_bit_function_BITWISE_AND_block_result

// Assignment
// DEBUG: Loading variable namespace_bit_function_get_last_bit_a from address 18
a0 := p(18) // Load a
push //  variable a
// DEBUG: Stack depth after push: 6
a0 := 2
push // Literal value2
// DEBUG: Stack depth after push: 7
stack/ // Binary operation
pop // Assign to a
// DEBUG: Stack depth after pop: 6
p(18) := a0 // Store namespace_bit_function_get_last_bit_a

// Assignment
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_b from address 19
a0 := p(19) // Load b
push //  variable b
// DEBUG: Stack depth after push: 7
a0 := 2
push // Literal value2
// DEBUG: Stack depth after push: 8
stack/ // Binary operation
pop // Assign to b
// DEBUG: Stack depth after pop: 7
p(19) := a0 // Store namespace_bit_function_BITWISE_AND_b

// Assignment
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_place from address 22
a0 := p(22) // Load place
push //  variable place
// DEBUG: Stack depth after push: 8
a0 := 2
push // Literal value2
// DEBUG: Stack depth after push: 9
stack* // Binary operation
pop // Assign to place
// DEBUG: Stack depth after pop: 8
p(22) := a0 // Store namespace_bit_function_BITWISE_AND_block_place

// Assignment
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_steps from address 20
a0 := p(20) // Load steps
push //  variable steps
// DEBUG: Stack depth after push: 9
a0 := 1
push // Literal value1
// DEBUG: Stack depth after push: 10
stack- // Binary operation
pop // Assign to steps
// DEBUG: Stack depth after pop: 9
p(20) := a0 // Store namespace_bit_function_BITWISE_AND_block_steps

goto loop29 // Jump back to loop start
endloop30:

// Return statement
// DEBUG: Loading variable namespace_bit_function_BITWISE_AND_block_result from address 21
a0 := p(21) // Load result
push //  variable result
// DEBUG: Stack depth after push: 10
return // Return from function
// Function BITWISE_XOR ends without explicit return

// Namespace: io
// Function declaration: readInput

namespace_io_readInput:
// DEBUG: Function readInput starts with stack depth: 0
// Array allocation
a0 := 256
push // Literal value256
// DEBUG: Stack depth after push: 1
pop // Get array size
// DEBUG: Stack depth after pop: 0
a1 := a0 // Store size in a1
a0 := 27 // Base address of allocated array
p(27) := 0 // Initialize element 0
p(28) := 0 // Initialize element 1
p(29) := 0 // Initialize element 2
p(30) := 0 // Initialize element 3
p(31) := 0 // Initialize element 4
p(32) := 0 // Initialize element 5
p(33) := 0 // Initialize element 6
p(34) := 0 // Initialize element 7
p(35) := 0 // Initialize element 8
p(36) := 0 // Initialize element 9
p(37) := 0 // Initialize element 10
p(38) := 0 // Initialize element 11
p(39) := 0 // Initialize element 12
p(40) := 0 // Initialize element 13
p(41) := 0 // Initialize element 14
p(42) := 0 // Initialize element 15
p(43) := 0 // Initialize element 16
p(44) := 0 // Initialize element 17
p(45) := 0 // Initialize element 18
p(46) := 0 // Initialize element 19
p(47) := 0 // Initialize element 20
p(48) := 0 // Initialize element 21
p(49) := 0 // Initialize element 22
p(50) := 0 // Initialize element 23
p(51) := 0 // Initialize element 24
p(52) := 0 // Initialize element 25
p(53) := 0 // Initialize element 26
p(54) := 0 // Initialize element 27
p(55) := 0 // Initialize element 28
p(56) := 0 // Initialize element 29
p(57) := 0 // Initialize element 30
p(58) := 0 // Initialize element 31
p(59) := 0 // Initialize element 32
p(60) := 0 // Initialize element 33
p(61) := 0 // Initialize element 34
p(62) := 0 // Initialize element 35
p(63) := 0 // Initialize element 36
p(64) := 0 // Initialize element 37
p(65) := 0 // Initialize element 38
p(66) := 0 // Initialize element 39
p(67) := 0 // Initialize element 40
p(68) := 0 // Initialize element 41
p(69) := 0 // Initialize element 42
p(70) := 0 // Initialize element 43
p(71) := 0 // Initialize element 44
p(72) := 0 // Initialize element 45
p(73) := 0 // Initialize element 46
p(74) := 0 // Initialize element 47
p(75) := 0 // Initialize element 48
p(76) := 0 // Initialize element 49
p(77) := 0 // Initialize element 50
p(78) := 0 // Initialize element 51
p(79) := 0 // Initialize element 52
p(80) := 0 // Initialize element 53
p(81) := 0 // Initialize element 54
p(82) := 0 // Initialize element 55
p(83) := 0 // Initialize element 56
p(84) := 0 // Initialize element 57
p(85) := 0 // Initialize element 58
p(86) := 0 // Initialize element 59
p(87) := 0 // Initialize element 60
p(88) := 0 // Initialize element 61
p(89) := 0 // Initialize element 62
p(90) := 0 // Initialize element 63
p(91) := 0 // Initialize element 64
p(92) := 0 // Initialize element 65
p(93) := 0 // Initialize element 66
p(94) := 0 // Initialize element 67
p(95) := 0 // Initialize element 68
p(96) := 0 // Initialize element 69
p(97) := 0 // Initialize element 70
p(98) := 0 // Initialize element 71
p(99) := 0 // Initialize element 72
p(100) := 0 // Initialize element 73
p(101) := 0 // Initialize element 74
p(102) := 0 // Initialize element 75
p(103) := 0 // Initialize element 76
p(104) := 0 // Initialize element 77
p(105) := 0 // Initialize element 78
p(106) := 0 // Initialize element 79
p(107) := 0 // Initialize element 80
p(108) := 0 // Initialize element 81
p(109) := 0 // Initialize element 82
p(110) := 0 // Initialize element 83
p(111) := 0 // Initialize element 84
p(112) := 0 // Initialize element 85
p(113) := 0 // Initialize element 86
p(114) := 0 // Initialize element 87
p(115) := 0 // Initialize element 88
p(116) := 0 // Initialize element 89
p(117) := 0 // Initialize element 90
p(118) := 0 // Initialize element 91
p(119) := 0 // Initialize element 92
p(120) := 0 // Initialize element 93
p(121) := 0 // Initialize element 94
p(122) := 0 // Initialize element 95
p(123) := 0 // Initialize element 96
p(124) := 0 // Initialize element 97
p(125) := 0 // Initialize element 98
p(126) := 0 // Initialize element 99
p(127) := 0 // Initialize element 100
p(128) := 0 // Initialize element 101
p(129) := 0 // Initialize element 102
p(130) := 0 // Initialize element 103
p(131) := 0 // Initialize element 104
p(132) := 0 // Initialize element 105
p(133) := 0 // Initialize element 106
p(134) := 0 // Initialize element 107
p(135) := 0 // Initialize element 108
p(136) := 0 // Initialize element 109
p(137) := 0 // Initialize element 110
p(138) := 0 // Initialize element 111
p(139) := 0 // Initialize element 112
p(140) := 0 // Initialize element 113
p(141) := 0 // Initialize element 114
p(142) := 0 // Initialize element 115
p(143) := 0 // Initialize element 116
p(144) := 0 // Initialize element 117
p(145) := 0 // Initialize element 118
p(146) := 0 // Initialize element 119
p(147) := 0 // Initialize element 120
p(148) := 0 // Initialize element 121
p(149) := 0 // Initialize element 122
p(150) := 0 // Initialize element 123
p(151) := 0 // Initialize element 124
p(152) := 0 // Initialize element 125
p(153) := 0 // Initialize element 126
p(154) := 0 // Initialize element 127
p(155) := 0 // Initialize element 128
p(156) := 0 // Initialize element 129
p(157) := 0 // Initialize element 130
p(158) := 0 // Initialize element 131
p(159) := 0 // Initialize element 132
p(160) := 0 // Initialize element 133
p(161) := 0 // Initialize element 134
p(162) := 0 // Initialize element 135
p(163) := 0 // Initialize element 136
p(164) := 0 // Initialize element 137
p(165) := 0 // Initialize element 138
p(166) := 0 // Initialize element 139
p(167) := 0 // Initialize element 140
p(168) := 0 // Initialize element 141
p(169) := 0 // Initialize element 142
p(170) := 0 // Initialize element 143
p(171) := 0 // Initialize element 144
p(172) := 0 // Initialize element 145
p(173) := 0 // Initialize element 146
p(174) := 0 // Initialize element 147
p(175) := 0 // Initialize element 148
p(176) := 0 // Initialize element 149
p(177) := 0 // Initialize element 150
p(178) := 0 // Initialize element 151
p(179) := 0 // Initialize element 152
p(180) := 0 // Initialize element 153
p(181) := 0 // Initialize element 154
p(182) := 0 // Initialize element 155
p(183) := 0 // Initialize element 156
p(184) := 0 // Initialize element 157
p(185) := 0 // Initialize element 158
p(186) := 0 // Initialize element 159
p(187) := 0 // Initialize element 160
p(188) := 0 // Initialize element 161
p(189) := 0 // Initialize element 162
p(190) := 0 // Initialize element 163
p(191) := 0 // Initialize element 164
p(192) := 0 // Initialize element 165
p(193) := 0 // Initialize element 166
p(194) := 0 // Initialize element 167
p(195) := 0 // Initialize element 168
p(196) := 0 // Initialize element 169
p(197) := 0 // Initialize element 170
p(198) := 0 // Initialize element 171
p(199) := 0 // Initialize element 172
p(200) := 0 // Initialize element 173
p(201) := 0 // Initialize element 174
p(202) := 0 // Initialize element 175
p(203) := 0 // Initialize element 176
p(204) := 0 // Initialize element 177
p(205) := 0 // Initialize element 178
p(206) := 0 // Initialize element 179
p(207) := 0 // Initialize element 180
p(208) := 0 // Initialize element 181
p(209) := 0 // Initialize element 182
p(210) := 0 // Initialize element 183
p(211) := 0 // Initialize element 184
p(212) := 0 // Initialize element 185
p(213) := 0 // Initialize element 186
p(214) := 0 // Initialize element 187
p(215) := 0 // Initialize element 188
p(216) := 0 // Initialize element 189
p(217) := 0 // Initialize element 190
p(218) := 0 // Initialize element 191
p(219) := 0 // Initialize element 192
p(220) := 0 // Initialize element 193
p(221) := 0 // Initialize element 194
p(222) := 0 // Initialize element 195
p(223) := 0 // Initialize element 196
p(224) := 0 // Initialize element 197
p(225) := 0 // Initialize element 198
p(226) := 0 // Initialize element 199
p(227) := 0 // Initialize element 200
p(228) := 0 // Initialize element 201
p(229) := 0 // Initialize element 202
p(230) := 0 // Initialize element 203
p(231) := 0 // Initialize element 204
p(232) := 0 // Initialize element 205
p(233) := 0 // Initialize element 206
p(234) := 0 // Initialize element 207
p(235) := 0 // Initialize element 208
p(236) := 0 // Initialize element 209
p(237) := 0 // Initialize element 210
p(238) := 0 // Initialize element 211
p(239) := 0 // Initialize element 212
p(240) := 0 // Initialize element 213
p(241) := 0 // Initialize element 214
p(242) := 0 // Initialize element 215
p(243) := 0 // Initialize element 216
p(244) := 0 // Initialize element 217
p(245) := 0 // Initialize element 218
p(246) := 0 // Initialize element 219
p(247) := 0 // Initialize element 220
p(248) := 0 // Initialize element 221
p(249) := 0 // Initialize element 222
p(250) := 0 // Initialize element 223
p(251) := 0 // Initialize element 224
p(252) := 0 // Initialize element 225
p(253) := 0 // Initialize element 226
p(254) := 0 // Initialize element 227
p(255) := 0 // Initialize element 228
p(256) := 0 // Initialize element 229
p(257) := 0 // Initialize element 230
p(258) := 0 // Initialize element 231
p(259) := 0 // Initialize element 232
p(260) := 0 // Initialize element 233
p(261) := 0 // Initialize element 234
p(262) := 0 // Initialize element 235
p(263) := 0 // Initialize element 236
p(264) := 0 // Initialize element 237
p(265) := 0 // Initialize element 238
p(266) := 0 // Initialize element 239
p(267) := 0 // Initialize element 240
p(268) := 0 // Initialize element 241
p(269) := 0 // Initialize element 242
p(270) := 0 // Initialize element 243
p(271) := 0 // Initialize element 244
p(272) := 0 // Initialize element 245
p(273) := 0 // Initialize element 246
p(274) := 0 // Initialize element 247
p(275) := 0 // Initialize element 248
p(276) := 0 // Initialize element 249
p(277) := 0 // Initialize element 250
p(278) := 0 // Initialize element 251
p(279) := 0 // Initialize element 252
p(280) := 0 // Initialize element 253
p(281) := 0 // Initialize element 254
p(282) := 0 // Initialize element 255
push //  array base address
// DEBUG: Stack depth after push: 1
pop // Initialize buf
// DEBUG: Stack depth after pop: 0
p(26) := a0 // Store namespace_io_function_readInput_block_buf
// Expression statement
// Syscall expression
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Get argument 0
// DEBUG: Stack depth after pop: 0
push //  syscall number
// DEBUG: Stack depth after push: 1
a0 := a0 // Store argument 0 in register a0
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Get argument 1
// DEBUG: Stack depth after pop: 1
a1 := a0 // Store argument 1 in register a1
// DEBUG: Loading variable namespace_io_function_readInput_block_buf from address 26
a0 := p(26) // Load buf
push //  variable buf
// DEBUG: Stack depth after push: 2
pop // Get argument 2
// DEBUG: Stack depth after pop: 1
a2 := a0 // Store argument 2 in register a2
a0 := 256
push // Literal value256
// DEBUG: Stack depth after push: 2
a0 := 8
push // Literal value8
// DEBUG: Stack depth after push: 3
stack* // Binary operation
pop // Get argument 3
// DEBUG: Stack depth after pop: 2
a3 := a0 // Store argument 3 in register a3
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 3
pop // Get argument 4
// DEBUG: Stack depth after pop: 2
a4 := a0 // Store argument 4 in register a4
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 3
pop // Get argument 5
// DEBUG: Stack depth after pop: 2
a5 := a0 // Store argument 5 in register a5
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 3
pop // Get argument 6
// DEBUG: Stack depth after pop: 2
a6 := a0 // Store argument 6 in register a6
pop // Get syscall number
// DEBUG: Stack depth after pop: 1
syscall // Execute system call
push //  syscall result
// DEBUG: Stack depth after push: 2
pop // Discard expression result
// DEBUG: Stack depth after pop: 1

// Return statement
// DEBUG: Loading variable namespace_io_function_readInput_block_buf from address 26
a0 := p(26) // Load buf
push //  variable buf
// DEBUG: Stack depth after push: 2
return // Return from function
// Function readInput ends without explicit return
// Function declaration: putchar

namespace_io_putchar:
// DEBUG: Function putchar starts with stack depth: 1
pop // Get parameter c
// DEBUG: Stack depth after pop: 0
p(283) := a0 // Store parameter c
// DEBUG: Parameter c stored at address 283
// Array allocation
a0 := 1
push // Literal value1
// DEBUG: Stack depth after push: 1
pop // Get array size
// DEBUG: Stack depth after pop: 0
a1 := a0 // Store size in a1
a0 := 285 // Base address of allocated array
p(285) := 0 // Initialize element 0
push //  array base address
// DEBUG: Stack depth after push: 1
pop // Initialize buf
// DEBUG: Stack depth after pop: 0
p(284) := a0 // Store namespace_io_function_readInput_block_buf
// Assignment
// DEBUG: Loading variable namespace_io_function_putchar_c from address 283
a0 := p(283) // Load c
push //  variable c
// DEBUG: Stack depth after push: 1
// Array access assignment
// DEBUG: Loading variable namespace_io_function_readInput_block_buf from address 284
a0 := p(284) // Load buf
push //  variable buf
// DEBUG: Stack depth after push: 2
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 3
pop // Get index
// DEBUG: Stack depth after pop: 2
a1 := a0 // Store index in a1
pop // Get array base address
// DEBUG: Stack depth after pop: 1
a2 := a0 + a1 // Calculate element address (base + index)
pop // Get assignment value
// DEBUG: Stack depth after pop: 0
p(a2) := a0 // Store value in array element

// Expression statement
// Syscall expression
a0 := 1
push // Literal value1
// DEBUG: Stack depth after push: 1
pop // Get argument 0
// DEBUG: Stack depth after pop: 0
push //  syscall number
// DEBUG: Stack depth after push: 1
a0 := a0 // Store argument 0 in register a0
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Get argument 1
// DEBUG: Stack depth after pop: 1
a1 := a0 // Store argument 1 in register a1
// DEBUG: Loading variable namespace_io_function_readInput_block_buf from address 284
a0 := p(284) // Load buf
push //  variable buf
// DEBUG: Stack depth after push: 2
pop // Get argument 2
// DEBUG: Stack depth after pop: 1
a2 := a0 // Store argument 2 in register a2
a0 := 8
push // Literal value8
// DEBUG: Stack depth after push: 2
pop // Get argument 3
// DEBUG: Stack depth after pop: 1
a3 := a0 // Store argument 3 in register a3
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Get argument 4
// DEBUG: Stack depth after pop: 1
a4 := a0 // Store argument 4 in register a4
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Get argument 5
// DEBUG: Stack depth after pop: 1
a5 := a0 // Store argument 5 in register a5
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Get argument 6
// DEBUG: Stack depth after pop: 1
a6 := a0 // Store argument 6 in register a6
pop // Get syscall number
// DEBUG: Stack depth after pop: 0
syscall // Execute system call
push //  syscall result
// DEBUG: Stack depth after push: 1
pop // Discard expression result
// DEBUG: Stack depth after pop: 0

// Return statement
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
return // Return from function
// Function putchar ends without explicit return
// Function declaration: puts

namespace_io_puts:
// DEBUG: Function puts starts with stack depth: 1
pop // Get parameter str
// DEBUG: Stack depth after pop: 0
p(286) := a0 // Store parameter str
// DEBUG: Parameter str stored at address 286
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Initialize len
// DEBUG: Stack depth after pop: 0
p(287) := a0 // Store namespace_io_function_puts_block_len
// While statement
loop41:
// Array access
// DEBUG: Loading variable namespace_io_function_puts_str from address 286
a0 := p(286) // Load str
push //  variable str
// DEBUG: Stack depth after push: 1
// DEBUG: Loading variable namespace_io_function_puts_block_len from address 287
a0 := p(287) // Load len
push //  variable len
// DEBUG: Stack depth after push: 2
pop // Get index
// DEBUG: Stack depth after pop: 1
a1 := a0 // Store index in a1
pop // Get array base address
// DEBUG: Stack depth after pop: 0
a0 := a0 + a1 // Calculate element address (base + index)
a0 := p(a0) // Load array element
push //  element value
// DEBUG: Stack depth after push: 1
a0 := 0
push // Character literal
// DEBUG: Stack depth after push: 2
pop // Get right operand
// DEBUG: Stack depth after pop: 1
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 0
if a0 != a1 then goto true43 // Jump if not equal
a0 := 0 // Comparison result: false
goto cmp_end44
true43:
a0 := 1 // Comparison result: true
cmp_end44:
push //  comparison result
// DEBUG: Stack depth after push: 1
pop // Get condition result
// DEBUG: Stack depth after pop: 0
a1 := 0
if a0 == a1 then goto endloop42 // Jump to end if condition is false
// Assignment
// DEBUG: Loading variable namespace_io_function_puts_block_len from address 287
a0 := p(287) // Load len
push //  variable len
// DEBUG: Stack depth after push: 1
a0 := 1
push // Literal value1
// DEBUG: Stack depth after push: 2
stack+ // Binary operation
pop // Assign to len
// DEBUG: Stack depth after pop: 1
p(287) := a0 // Store namespace_io_function_puts_block_len

goto loop41 // Jump back to loop start
endloop42:

a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Initialize i
// DEBUG: Stack depth after pop: 1
p(288) := a0 // Store namespace_io_function_puts_block_i
// While statement
loop45:
// DEBUG: Loading variable namespace_io_function_puts_block_i from address 288
a0 := p(288) // Load i
push //  variable i
// DEBUG: Stack depth after push: 2
// DEBUG: Loading variable namespace_io_function_puts_block_len from address 287
a0 := p(287) // Load len
push //  variable len
// DEBUG: Stack depth after push: 3
pop // Get right operand
// DEBUG: Stack depth after pop: 2
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 1
if a0 < a1 then goto true47 // Jump if less than
a0 := 0 // Comparison result: false
goto cmp_end48
true47:
a0 := 1 // Comparison result: true
cmp_end48:
push //  comparison result
// DEBUG: Stack depth after push: 2
pop // Get condition result
// DEBUG: Stack depth after pop: 1
a1 := 0
if a0 == a1 then goto endloop46 // Jump to end if condition is false
// Array access
// DEBUG: Loading variable namespace_io_function_puts_str from address 286
a0 := p(286) // Load str
push //  variable str
// DEBUG: Stack depth after push: 2
// DEBUG: Loading variable namespace_io_function_puts_block_i from address 288
a0 := p(288) // Load i
push //  variable i
// DEBUG: Stack depth after push: 3
pop // Get index
// DEBUG: Stack depth after pop: 2
a1 := a0 // Store index in a1
pop // Get array base address
// DEBUG: Stack depth after pop: 1
a0 := a0 + a1 // Calculate element address (base + index)
a0 := p(a0) // Load array element
push //  element value
// DEBUG: Stack depth after push: 2
pop // Initialize c
// DEBUG: Stack depth after pop: 1
p(289) := a0 // Store namespace_io_function_putchar_c
// Expression statement
// Function call: putchar
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_io_function_putchar_c from address 289
a0 := p(289) // Load c
push //  variable c
// DEBUG: Stack depth after push: 2
call namespace_io_putchar // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 1

// Assignment
// DEBUG: Loading variable namespace_io_function_puts_block_i from address 288
a0 := p(288) // Load i
push //  variable i
// DEBUG: Stack depth after push: 2
a0 := 1
push // Literal value1
// DEBUG: Stack depth after push: 3
stack+ // Binary operation
pop // Assign to i
// DEBUG: Stack depth after pop: 2
p(288) := a0 // Store namespace_io_function_puts_block_i

goto loop45 // Jump back to loop start
endloop46:

// Return statement
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 3
return // Return from function
// Function puts ends without explicit return

// Namespace: LinkedList
// Layout declaration: Node
// DEBUG: Processing layout declaration for Node
// DEBUG: Setting up layout 'Node' with 2 members
// DEBUG: Found layout symbol with FQDN: namespace_LinkedList_Node
// DEBUG: Layout is in namespace: namespace_LinkedList
// DEBUG: Layout namespace_LinkedList_Node member 'data' at offset 0
// DEBUG: Layout namespace_LinkedList_Node member 'next' at offset 1

// Layout declaration: List
// DEBUG: Processing layout declaration for List
// DEBUG: Setting up layout 'List' with 6 members
// DEBUG: Found layout symbol with FQDN: namespace_LinkedList_List
// DEBUG: Layout is in namespace: namespace_LinkedList
// DEBUG: Layout namespace_LinkedList_List member 'head' at offset 0
// DEBUG: Layout namespace_LinkedList_List member 'tail' at offset 1
// DEBUG: Layout namespace_LinkedList_List member 'size' at offset 2
// DEBUG: Layout namespace_LinkedList_List member 'capacity' at offset 3
// DEBUG: Layout namespace_LinkedList_List member 'last_size' at offset 4
// DEBUG: Layout namespace_LinkedList_List member 'current_ptr' at offset 5

// Function declaration: create_list

namespace_LinkedList_create_list:
// DEBUG: Function create_list starts with stack depth: 1
pop // Get parameter capacity
// DEBUG: Stack depth after pop: 0
p(290) := a0 // Store parameter capacity
// DEBUG: Parameter capacity stored at address 290
// DEBUG: Tracking variable namespace_LinkedList_function_create_list_block_list as layout type namespace_LinkedList_List
// Array allocation
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Get array size
// DEBUG: Stack depth after pop: 0
a1 := a0 // Store size in a1
a0 := 298 // Base address of allocated array
push //  array base address
// DEBUG: Stack depth after push: 1
pop // Initialize list
// DEBUG: Stack depth after pop: 0
p(297) := a0 // Store namespace_LinkedList_function_create_list_block_list
// Assignment
// Type cast
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
// Raw pointer cast (no conversion needed)
// Member access assignment
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// Warning: Using default offset 0 for member assignment head (layout: ) | namespace_LinkedList_function_create_list_block_list
pop // Get assignment value
// DEBUG: Stack depth after pop: 0
p(297) := a0 // Store value in member head

// Assignment
// Type cast
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
// Raw pointer cast (no conversion needed)
// Member access assignment
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// Warning: Using default offset 0 for member assignment tail (layout: ) | namespace_LinkedList_function_create_list_block_list
pop // Get assignment value
// DEBUG: Stack depth after pop: 0
p(297) := a0 // Store value in member tail

// Assignment
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
// Member access assignment
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// Warning: Using default offset 0 for member assignment size (layout: ) | namespace_LinkedList_function_create_list_block_list
pop // Get assignment value
// DEBUG: Stack depth after pop: 0
p(297) := a0 // Store value in member size

// Assignment
// DEBUG: Loading variable namespace_LinkedList_function_create_list_capacity from address 290
a0 := p(290) // Load capacity
push //  variable capacity
// DEBUG: Stack depth after push: 1
// Member access assignment
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// Warning: Using default offset 0 for member assignment capacity (layout: ) | namespace_LinkedList_function_create_list_block_list
pop // Get assignment value
// DEBUG: Stack depth after pop: 0
p(297) := a0 // Store value in member capacity

// Assignment
// Unary expression
// Warning: Reference operator on non-identifier
a0 := 0
push //  null address
// DEBUG: Stack depth after push: 1
// Member access assignment
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// Warning: Using default offset 0 for member assignment current_ptr (layout: ) | namespace_LinkedList_function_create_list_block_list
pop // Get assignment value
// DEBUG: Stack depth after pop: 0
p(297) := a0 // Store value in member current_ptr

// Assignment
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
// Member access assignment
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// Warning: Using default offset 0 for member assignment last_size (layout: ) | namespace_LinkedList_function_create_list_block_list
pop // Get assignment value
// DEBUG: Stack depth after pop: 0
p(297) := a0 // Store value in member last_size

// Return statement
// Type cast
// DEBUG: Loading variable namespace_LinkedList_function_create_list_block_list from address 297
a0 := p(297) // Load list
push //  variable list
// DEBUG: Stack depth after push: 1
// Raw pointer cast (no conversion needed)
return // Return from function
// Function create_list ends without explicit return
// Function declaration: create_node

namespace_LinkedList_create_node:
// DEBUG: Function create_node starts with stack depth: 1
pop // Get parameter data
// DEBUG: Stack depth after pop: 0
p(298) := a0 // Store parameter data
// DEBUG: Parameter data stored at address 298
// DEBUG: Tracking variable namespace_LinkedList_function_create_node_block_node as layout type namespace_LinkedList_Node
// Array allocation
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Get array size
// DEBUG: Stack depth after pop: 0
a1 := a0 // Store size in a1
a0 := 302 // Base address of allocated array
push //  array base address
// DEBUG: Stack depth after push: 1
pop // Initialize node
// DEBUG: Stack depth after pop: 0
p(301) := a0 // Store namespace_LinkedList_function_create_node_block_node
// Assignment
// DEBUG: Loading variable namespace_LinkedList_function_create_node_data from address 298
a0 := p(298) // Load data
push //  variable data
// DEBUG: Stack depth after push: 1
// Member access assignment
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_node_block_node
// Warning: Using default offset 0 for member assignment data (layout: ) | namespace_LinkedList_function_create_node_block_node
pop // Get assignment value
// DEBUG: Stack depth after pop: 0
p(301) := a0 // Store value in member data

// Assignment
// Unary expression
// Warning: Reference operator on non-identifier
a0 := 0
push //  null address
// DEBUG: Stack depth after push: 1
// Member access assignment
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_node_block_node
// Warning: Using default offset 0 for member assignment next (layout: ) | namespace_LinkedList_function_create_node_block_node
pop // Get assignment value
// DEBUG: Stack depth after pop: 0
p(301) := a0 // Store value in member next

// Return statement
// DEBUG: Loading variable namespace_LinkedList_function_create_node_block_node from address 301
a0 := p(301) // Load node
push //  variable node
// DEBUG: Stack depth after push: 1
return // Return from function
// Function create_node ends without explicit return
// Function declaration: add_node

namespace_LinkedList_add_node:
// DEBUG: Function add_node starts with stack depth: 2
pop // Get parameter list_ptr
// DEBUG: Stack depth after pop: 1
p(302) := a0 // Store parameter list_ptr
// DEBUG: Parameter list_ptr stored at address 302
// DEBUG: Tracking variable namespace_LinkedList_function_create_node_block_node as layout type namespace_LinkedList_Node
pop // Get parameter node
// DEBUG: Stack depth after pop: 0
p(303) := a0 // Store parameter node
// DEBUG: Parameter node stored at address 303
// DEBUG: Tracking variable namespace_LinkedList_function_create_list_block_list as layout type namespace_LinkedList_List
// Type cast
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 302
a0 := p(302) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 1
// Raw pointer cast (no conversion needed)
pop // Initialize list
// DEBUG: Stack depth after pop: 0
p(310) := a0 // Store namespace_LinkedList_function_create_list_block_list
// If statement
// DEBUG: Loading variable namespace_LinkedList_function_create_list_block_list from address 310
a0 := p(310) // Load list
push //  variable list
// DEBUG: Stack depth after push: 1
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// DEBUG: Layout type not found for namespace_LinkedList_function_create_list_block_list
// DEBUG: Loading variable namespace_LinkedList_function_create_list_block_list from address 310
a0 := p(310) // Load list
push //  variable list
// DEBUG: Stack depth after push: 2
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// DEBUG: Layout type not found for namespace_LinkedList_function_create_list_block_list
pop // Get right operand
// DEBUG: Stack depth after pop: 1
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 0
if a0 >= a1 then goto true51 // Jump if greater than or equal
a0 := 0 // Comparison result: false
goto cmp_end52
true51:
a0 := 1 // Comparison result: true
cmp_end52:
push //  comparison result
// DEBUG: Stack depth after push: 1
pop // Get condition result
// DEBUG: Stack depth after pop: 0
a1 := 0
if a0 == a1 then goto else49 // Jump to else if condition is false
// Return statement
// Unary expression
a0 := 1
push // Literal value1
// DEBUG: Stack depth after push: 1
pop // Get value
// DEBUG: Stack depth after pop: 0
a1 := 0
a0 := a1 - a0 // Negate value
push //  negated value
// DEBUG: Stack depth after push: 1
return // Return from function
goto endif50 // Jump to end
else49:
endif50:

// If statement
// DEBUG: Loading variable namespace_LinkedList_function_create_list_block_list from address 310
a0 := p(310) // Load list
push //  variable list
// DEBUG: Stack depth after push: 2
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// DEBUG: Layout type not found for namespace_LinkedList_function_create_list_block_list
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 3
pop // Get right operand
// DEBUG: Stack depth after pop: 2
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 1
if a0 == a1 then goto true55 // Jump if equal
a0 := 0 // Comparison result: false
goto cmp_end56
true55:
a0 := 1 // Comparison result: true
cmp_end56:
push //  comparison result
// DEBUG: Stack depth after push: 2
pop // Get condition result
// DEBUG: Stack depth after pop: 1
a1 := 0
if a0 == a1 then goto else53 // Jump to else if condition is false
// Assignment
// DEBUG: Loading variable namespace_LinkedList_function_create_node_block_node from address 303
a0 := p(303) // Load node
push //  variable node
// DEBUG: Stack depth after push: 2
// Member access assignment
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// Warning: Using default offset 0 for member assignment head (layout: ) | namespace_LinkedList_function_create_list_block_list
pop // Get assignment value
// DEBUG: Stack depth after pop: 1
p(310) := a0 // Store value in member head

// Assignment
// DEBUG: Loading variable namespace_LinkedList_function_create_node_block_node from address 303
a0 := p(303) // Load node
push //  variable node
// DEBUG: Stack depth after push: 2
// Member access assignment
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// Warning: Using default offset 0 for member assignment tail (layout: ) | namespace_LinkedList_function_create_list_block_list
pop // Get assignment value
// DEBUG: Stack depth after pop: 1
p(310) := a0 // Store value in member tail

goto endif54 // Jump to end
else53:
// Assignment
// Type cast
// DEBUG: Loading variable namespace_LinkedList_function_create_node_block_node from address 303
a0 := p(303) // Load node
push //  variable node
// DEBUG: Stack depth after push: 2
// Raw pointer cast (no conversion needed)
// Member access assignment
// Warning: Complex member assignment not supported
pop // Discard assignment value
// DEBUG: Stack depth after pop: 1

// Assignment
// DEBUG: Loading variable namespace_LinkedList_function_create_node_block_node from address 303
a0 := p(303) // Load node
push //  variable node
// DEBUG: Stack depth after push: 2
// Member access assignment
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// Warning: Using default offset 0 for member assignment tail (layout: ) | namespace_LinkedList_function_create_list_block_list
pop // Get assignment value
// DEBUG: Stack depth after pop: 1
p(310) := a0 // Store value in member tail

endif54:

// Assignment
// DEBUG: Loading variable namespace_LinkedList_function_create_list_block_list from address 310
a0 := p(310) // Load list
push //  variable list
// DEBUG: Stack depth after push: 2
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// DEBUG: Layout type not found for namespace_LinkedList_function_create_list_block_list
a0 := 1
push // Literal value1
// DEBUG: Stack depth after push: 3
stack+ // Binary operation
// Member access assignment
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// Warning: Using default offset 0 for member assignment size (layout: ) | namespace_LinkedList_function_create_list_block_list
pop // Get assignment value
// DEBUG: Stack depth after pop: 2
p(310) := a0 // Store value in member size

// Return statement
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 3
return // Return from function
// Function add_node ends without explicit return
// Function declaration: remove_node

namespace_LinkedList_remove_node:
// DEBUG: Function remove_node starts with stack depth: 2
// DEBUG: Tracking variable namespace_LinkedList_function_create_list_block_list as layout type namespace_LinkedList_List
pop // Get parameter list
// DEBUG: Stack depth after pop: 1
p(311) := a0 // Store parameter list
// DEBUG: Parameter list stored at address 311
// DEBUG: Tracking variable namespace_LinkedList_function_create_node_block_node as layout type namespace_LinkedList_Node
pop // Get parameter node
// DEBUG: Stack depth after pop: 0
p(312) := a0 // Store parameter node
// DEBUG: Parameter node stored at address 312
// If statement
// DEBUG: Loading variable namespace_LinkedList_function_create_list_block_list from address 311
a0 := p(311) // Load list
push //  variable list
// DEBUG: Stack depth after push: 1
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// DEBUG: Layout type not found for namespace_LinkedList_function_create_list_block_list
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 2
pop // Get right operand
// DEBUG: Stack depth after pop: 1
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 0
if a0 == a1 then goto true59 // Jump if equal
a0 := 0 // Comparison result: false
goto cmp_end60
true59:
a0 := 1 // Comparison result: true
cmp_end60:
push //  comparison result
// DEBUG: Stack depth after push: 1
pop // Get condition result
// DEBUG: Stack depth after pop: 0
a1 := 0
if a0 == a1 then goto else57 // Jump to else if condition is false
// Return statement
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
return // Return from function
goto endif58 // Jump to end
else57:
endif58:

// If statement
// DEBUG: Loading variable namespace_LinkedList_function_create_list_block_list from address 311
a0 := p(311) // Load list
push //  variable list
// DEBUG: Stack depth after push: 2
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// DEBUG: Layout type not found for namespace_LinkedList_function_create_list_block_list
// DEBUG: Loading variable namespace_LinkedList_function_create_node_block_node from address 312
a0 := p(312) // Load node
push //  variable node
// DEBUG: Stack depth after push: 3
pop // Get right operand
// DEBUG: Stack depth after pop: 2
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 1
if a0 == a1 then goto true63 // Jump if equal
a0 := 0 // Comparison result: false
goto cmp_end64
true63:
a0 := 1 // Comparison result: true
cmp_end64:
push //  comparison result
// DEBUG: Stack depth after push: 2
pop // Get condition result
// DEBUG: Stack depth after pop: 1
a1 := 0
if a0 == a1 then goto else61 // Jump to else if condition is false
// Assignment
// Type cast
// DEBUG: Loading variable namespace_LinkedList_function_create_list_block_list from address 311
a0 := p(311) // Load list
push //  variable list
// DEBUG: Stack depth after push: 2
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// DEBUG: Layout type not found for namespace_LinkedList_function_create_list_block_list
// DEBUG: Variable list.head not found in symbol table
// DEBUG: Layout type not found for list.head
// Raw pointer cast (no conversion needed)
// Member access assignment
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// Warning: Using default offset 0 for member assignment head (layout: ) | namespace_LinkedList_function_create_list_block_list
pop // Get assignment value
// DEBUG: Stack depth after pop: 1
p(311) := a0 // Store value in member head

goto endif62 // Jump to end
else61:
endif62:

// If statement
// DEBUG: Loading variable namespace_LinkedList_function_create_list_block_list from address 311
a0 := p(311) // Load list
push //  variable list
// DEBUG: Stack depth after push: 2
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// DEBUG: Layout type not found for namespace_LinkedList_function_create_list_block_list
// DEBUG: Loading variable namespace_LinkedList_function_create_node_block_node from address 312
a0 := p(312) // Load node
push //  variable node
// DEBUG: Stack depth after push: 3
pop // Get right operand
// DEBUG: Stack depth after pop: 2
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 1
if a0 == a1 then goto true67 // Jump if equal
a0 := 0 // Comparison result: false
goto cmp_end68
true67:
a0 := 1 // Comparison result: true
cmp_end68:
push //  comparison result
// DEBUG: Stack depth after push: 2
pop // Get condition result
// DEBUG: Stack depth after pop: 1
a1 := 0
if a0 == a1 then goto else65 // Jump to else if condition is false
// Assignment
// DEBUG: Loading variable namespace_LinkedList_function_create_list_block_list from address 311
a0 := p(311) // Load list
push //  variable list
// DEBUG: Stack depth after push: 2
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// DEBUG: Layout type not found for namespace_LinkedList_function_create_list_block_list
// Member access assignment
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// Warning: Using default offset 0 for member assignment tail (layout: ) | namespace_LinkedList_function_create_list_block_list
pop // Get assignment value
// DEBUG: Stack depth after pop: 1
p(311) := a0 // Store value in member tail

goto endif66 // Jump to end
else65:
endif66:

// Assignment
// DEBUG: Loading variable namespace_LinkedList_function_create_list_block_list from address 311
a0 := p(311) // Load list
push //  variable list
// DEBUG: Stack depth after push: 2
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// DEBUG: Layout type not found for namespace_LinkedList_function_create_list_block_list
a0 := 1
push // Literal value1
// DEBUG: Stack depth after push: 3
stack- // Binary operation
// Member access assignment
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// Warning: Using default offset 0 for member assignment size (layout: ) | namespace_LinkedList_function_create_list_block_list
pop // Get assignment value
// DEBUG: Stack depth after pop: 2
p(311) := a0 // Store value in member size

// Function remove_node ends without explicit return

// Function declaration: createCharNode

createCharNode:
// DEBUG: Function createCharNode starts with stack depth: 1
pop // Get parameter data
// DEBUG: Stack depth after pop: 0
p(313) := a0 // Store parameter data
// DEBUG: Parameter data stored at address 313
// DEBUG: Tracking variable namespace_LinkedList_function_create_node_block_node as layout type namespace_LinkedList_Node
// Function call: LinkedList.create_node
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_create_node_data from address 313
a0 := p(313) // Load data
push //  variable data
// DEBUG: Stack depth after push: 1
call namespace_LinkedList_create_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Initialize node
// DEBUG: Stack depth after pop: 0
p(316) := a0 // Store namespace_LinkedList_function_create_node_block_node
// Return statement
// DEBUG: Loading variable namespace_LinkedList_function_create_node_block_node from address 316
a0 := p(316) // Load node
push //  variable node
// DEBUG: Stack depth after push: 1
return // Return from function
// Function createCharNode ends without explicit return
// Function declaration: main
main:          
 p(0) := 374 // Highest memory address used: 374
// DEBUG: Function main starts with stack depth: 0
// Function call: LinkedList.create_list
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
call namespace_LinkedList_create_list // Function call
// DEBUG: Function call completed - return value is on stack
pop // Initialize list_ptr
// DEBUG: Stack depth after pop: 0
p(317) := a0 // Store namespace_LinkedList_function_add_node_list_ptr
// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(318) := 97 // <char alloc>
p(319) := 0 // Null terminator
a0 := 318 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 1
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 2
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 1

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(320) := 98 // <char alloc>
p(321) := 0 // Null terminator
a0 := 320 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 2
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 3
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 2

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(322) := 99 // <char alloc>
p(323) := 0 // Null terminator
a0 := 322 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 3
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 4
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 3

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(324) := 100 // <char alloc>
p(325) := 0 // Null terminator
a0 := 324 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 4
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 5
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 4

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(326) := 101 // <char alloc>
p(327) := 0 // Null terminator
a0 := 326 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 5
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 6
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 5

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(328) := 102 // <char alloc>
p(329) := 0 // Null terminator
a0 := 328 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 6
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 7
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 6

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(330) := 103 // <char alloc>
p(331) := 0 // Null terminator
a0 := 330 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 7
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 8
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 7

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(332) := 104 // <char alloc>
p(333) := 0 // Null terminator
a0 := 332 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 8
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 9
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 8

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(334) := 105 // <char alloc>
p(335) := 0 // Null terminator
a0 := 334 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 9
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 10
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 9

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(336) := 106 // <char alloc>
p(337) := 0 // Null terminator
a0 := 336 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 10
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 11
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 10

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(338) := 107 // <char alloc>
p(339) := 0 // Null terminator
a0 := 338 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 11
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 12
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 11

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(340) := 108 // <char alloc>
p(341) := 0 // Null terminator
a0 := 340 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 12
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 13
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 12

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(342) := 109 // <char alloc>
p(343) := 0 // Null terminator
a0 := 342 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 13
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 14
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 13

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(344) := 110 // <char alloc>
p(345) := 0 // Null terminator
a0 := 344 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 14
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 15
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 14

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(346) := 111 // <char alloc>
p(347) := 0 // Null terminator
a0 := 346 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 15
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 16
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 15

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(348) := 112 // <char alloc>
p(349) := 0 // Null terminator
a0 := 348 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 16
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 17
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 16

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(350) := 113 // <char alloc>
p(351) := 0 // Null terminator
a0 := 350 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 17
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 18
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 17

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(352) := 114 // <char alloc>
p(353) := 0 // Null terminator
a0 := 352 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 18
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 19
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 18

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(354) := 115 // <char alloc>
p(355) := 0 // Null terminator
a0 := 354 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 19
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 20
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 19

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(356) := 116 // <char alloc>
p(357) := 0 // Null terminator
a0 := 356 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 20
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 21
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 20

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(358) := 117 // <char alloc>
p(359) := 0 // Null terminator
a0 := 358 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 21
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 22
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 21

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(360) := 118 // <char alloc>
p(361) := 0 // Null terminator
a0 := 360 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 22
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 23
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 22

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(362) := 119 // <char alloc>
p(363) := 0 // Null terminator
a0 := 362 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 23
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 24
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 23

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(364) := 120 // <char alloc>
p(365) := 0 // Null terminator
a0 := 364 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 24
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 25
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 24

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(366) := 121 // <char alloc>
p(367) := 0 // Null terminator
a0 := 366 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 25
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 26
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 25

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(368) := 122 // <char alloc>
p(369) := 0 // Null terminator
a0 := 368 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 26
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 27
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 26

// Expression statement
// Function call: LinkedList.add_node
// DEBUG: Pushing 2 arguments
// DEBUG: Pushing argument 1
// Function call: createCharNode
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
p(370) := 101 // <char alloc>
p(371) := 0 // Null terminator
a0 := 370 // Base address of string array
push //  string array address
// DEBUG: Stack depth after push: 27
call createCharNode // Function call
// DEBUG: Function call completed - return value is on stack
// DEBUG: Pushing argument 0
// DEBUG: Loading variable namespace_LinkedList_function_add_node_list_ptr from address 317
a0 := p(317) // Load list_ptr
push //  variable list_ptr
// DEBUG: Stack depth after push: 28
call namespace_LinkedList_add_node // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 27

// DEBUG: Tracking variable function_main_block_current as layout type namespace_LinkedList_Node
// WARNING: Undefined variable namespace_LinkedList_function_create_list_block_list - using 0
a0 := 0
push //  undefined variable list
// DEBUG: Stack depth after push: 28
// DEBUG: No layout type found for variable namespace_LinkedList_function_create_list_block_list
// DEBUG: Layout type not found for namespace_LinkedList_function_create_list_block_list
pop // Initialize current
// DEBUG: Stack depth after pop: 27
p(374) := a0 // Store function_main_block_current
// While statement
loop69:
// DEBUG: Loading variable function_main_block_current from address 374
a0 := p(374) // Load current
push //  variable current
// DEBUG: Stack depth after push: 28
// Array allocation
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 29
pop // Get array size
// DEBUG: Stack depth after pop: 28
a1 := a0 // Store size in a1
a0 := 375 // Base address of allocated array
push //  array base address
// DEBUG: Stack depth after push: 29
pop // Get right operand
// DEBUG: Stack depth after pop: 28
a1 := a0
pop // Get left operand
// DEBUG: Stack depth after pop: 27
if a0 != a1 then goto true71 // Jump if not equal
a0 := 0 // Comparison result: false
goto cmp_end72
true71:
a0 := 1 // Comparison result: true
cmp_end72:
push //  comparison result
// DEBUG: Stack depth after push: 28
pop // Get condition result
// DEBUG: Stack depth after pop: 27
a1 := 0
if a0 == a1 then goto endloop70 // Jump to end if condition is false
// Expression statement
// Function call: io.puts
// DEBUG: Pushing 1 arguments
// DEBUG: Pushing argument 0
// Type cast
// DEBUG: Loading variable function_main_block_current from address 374
a0 := p(374) // Load current
push //  variable current
// DEBUG: Stack depth after push: 28
// DEBUG: No layout type found for variable function_main_block_current
// DEBUG: Layout type not found for function_main_block_current
// Raw pointer cast (no conversion needed)
call namespace_io_puts // Function call
// DEBUG: Function call completed - return value is on stack
pop // Discard expression result
// DEBUG: Stack depth after pop: 27

// Assignment
// Type cast
// DEBUG: Loading variable function_main_block_current from address 374
a0 := p(374) // Load current
push //  variable current
// DEBUG: Stack depth after push: 28
// DEBUG: No layout type found for variable function_main_block_current
// DEBUG: Layout type not found for function_main_block_current
// Raw pointer cast (no conversion needed)
pop // Assign to current
// DEBUG: Stack depth after pop: 27
p(374) := a0 // Store function_main_block_current

goto loop69 // Jump back to loop start
endloop70:

// Return statement
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 28
return // Return from function
// Function main ends without explicit return

// Program termination
goto END
