// Generated by C-Alpha Compiler
// Target: Alpha_TUI Assembly

// Layout declaration: C
// DEBUG: Processing layout declaration for C
// DEBUG: Setting up layout 'C' with 2 members
// DEBUG: Found layout symbol with FQDN: C
// DEBUG: Layout is in namespace: global
// DEBUG: Layout C member 'value' at offset 1
// DEBUG: Layout C member 'ptr' at offset 2

// Function declaration: main
main:          
 p(0) := 0 // Highest memory address used: 0
// DEBUG: Function main starts with stack depth: 0
// DEBUG: Tracking variable function_main_block_c as layout type C
// DEBUG: Found layout type C for variable function_main_block_c
// DEBUG: Tracking variable function_main_block_c as layout type C
// Layout initialization for function_main_block_c (layout: C)
p(3) := 3 // Store base address for layout C
a0 := 1
push // Literal value1
// DEBUG: Stack depth after push: 1
pop // Get layout member value 0
// DEBUG: Stack depth after pop: 0
p(4) := a0 // Store member 0
// Type cast
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
// Raw pointer cast (no conversion needed)
pop // Get layout member value 1
// DEBUG: Stack depth after pop: 0
p(5) := a0 // Store member 1
// DEBUG: Tracking variable function_main_block_other as layout type C
// DEBUG: Found pointer to layout type C for variable function_main_block_other
// DEBUG: Tracking variable function_main_block_other as layout type C
// Layout initialization for function_main_block_other (layout: C)
p(6) := 6 // Store base address for layout C
a0 := 2
push // Literal value2
// DEBUG: Stack depth after push: 1
pop // Get layout member value 0
// DEBUG: Stack depth after pop: 0
p(7) := a0 // Store member 0
a0 := 0
push // Literal value0
// DEBUG: Stack depth after push: 1
pop // Get layout member value 1
// DEBUG: Stack depth after pop: 0
p(8) := a0 // Store member 1
// Assignment
// DEBUG: Loading variable function_main_block_other from address 6
// DEBUG: Found pointer to layout type C for variable function_main_block_other
// DEBUG: Tracking variable function_main_block_other as layout type C
a0 := p(6) // Load layout base address for other
// DEBUG: Variable other is layout type C
push //  variable other
// DEBUG: Stack depth after push: 1
// Member access assignment
// DEBUG: Found layout type C for variable function_main_block_c
// DEBUG: Tracking variable function_main_block_c as layout type C
// DEBUG: Found member ptr in layout C at offset 2
// DEBUG: Loading variable function_main_block_c from address 3
// DEBUG: Found layout type C for variable function_main_block_c
// DEBUG: Tracking variable function_main_block_c as layout type C
a0 := p(3) // Load layout base address for c
// DEBUG: Variable c is layout type C
push //  variable c
// DEBUG: Stack depth after push: 2
pop // Get object base address
// DEBUG: Stack depth after pop: 1
a1 := a0 + 2 // Calculate member address (c.ptr)
pop // Get assignment value
// DEBUG: Stack depth after pop: 0
p(a1) := a0 // Store value in member ptr

// Return statement
// DEBUG: Handling dereference in member access
// DEBUG: Found layout type C for variable function_main_block_c
// DEBUG: Tracking variable function_main_block_c as layout type C
// DEBUG: Analyzing dereference of member access c.ptr
// DEBUG: Base object c has layout type C
// DEBUG: Found member ptr with type ->layout C
// DEBUG: Dereference member access: (<-c.ptr) has layout type C
// Unary expression
// DEBUG: Found layout type C for variable function_main_block_c
// DEBUG: Tracking variable function_main_block_c as layout type C
// DEBUG: Simple identifier access: function_main_block_c has layout type C
// DEBUG: Loading variable function_main_block_c from address 3
// DEBUG: Found layout type C for variable function_main_block_c
// DEBUG: Tracking variable function_main_block_c as layout type C
a0 := p(3) // Load layout base address for c
// DEBUG: Variable c is layout type C
push //  variable c
// DEBUG: Stack depth after push: 1
// DEBUG: Found member ptr in layout C at offset 2
pop // Get base address
// DEBUG: Stack depth after pop: 0
a0 := a0 + 2 // Add total member offset
a0 := p(a0) // Load member value
push //  member value
// DEBUG: Stack depth after push: 1
pop // Get address
// DEBUG: Stack depth after pop: 0
a0 := p(a0) // Dereference address
push //  dereferenced value
// DEBUG: Stack depth after push: 1
// DEBUG: Found member value in layout C at offset 1
pop // Get base address
// DEBUG: Stack depth after pop: 0
a0 := a0 + 1 // Add total member offset
a0 := p(a0) // Load member value
push //  member value
// DEBUG: Stack depth after push: 1
return // Return from function
// Function main ends without explicit return

// Program termination
goto END
