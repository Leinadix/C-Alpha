#include <codegen.hpp>
#include <iostream>
#include <stdexcept>

namespace calpha {

// ============================================================================
// RegisterAllocator Implementation
// ============================================================================

RegisterAllocator::RegisterAllocator() {
    // Initialize all 8 registers as available (a0-a7)
    for (int i = 0; i < 8; ++i) {
        availableRegisters.insert(i);
    }
}

int RegisterAllocator::allocateRegister(const std::string &variableName) {
    if (availableRegisters.empty()) {
        throw CodeGeneratorError("No available registers for allocation");
    }

    int registerIndex = *availableRegisters.begin();
    availableRegisters.erase(registerIndex);

    if (!variableName.empty()) {
        variableToRegister[variableName] = registerIndex;
    }

    return registerIndex;
}

void RegisterAllocator::deallocateRegister(int registerIndex) {
    if (registerIndex < 0 || registerIndex >= 8) {
        throw CodeGeneratorError("Invalid register index: " +
                                 std::to_string(registerIndex));
    }

    availableRegisters.insert(registerIndex);

    // Remove from variable mapping
    for (auto iter = variableToRegister.begin(); iter != variableToRegister.end();
         ++iter) {
        if (iter->second == registerIndex) {
            variableToRegister.erase(iter);
            break;
        }
    }
}

void RegisterAllocator::deallocateVariable(const std::string &variableName) {
    auto iter = variableToRegister.find(variableName);
    if (iter != variableToRegister.end()) {
        deallocateRegister(iter->second);
    }
}

bool RegisterAllocator::isVariableInRegister(
    const std::string &variableName) const {
    return variableToRegister.find(variableName) != variableToRegister.end();
}

int RegisterAllocator::getVariableRegister(
    const std::string &variableName) const {
    auto iter = variableToRegister.find(variableName);
    if (iter == variableToRegister.end()) {
        throw CodeGeneratorError("Variable '" + variableName +
                                 "' not in register");
    }
    return iter->second;
}

std::string RegisterAllocator::getRegisterName(int registerIndex) {
    if (registerIndex < 0 || registerIndex >= 8) {
        throw CodeGeneratorError("Invalid register index: " +
                                 std::to_string(registerIndex));
    }
    return "a" + std::to_string(registerIndex);
}

bool RegisterAllocator::hasAvailableRegister() const {
    return !availableRegisters.empty();
}

void RegisterAllocator::clearAll() {
    availableRegisters.clear();
    variableToRegister.clear();
    for (int i = 0; i < 8; ++i) {
        availableRegisters.insert(i);
    }
}

// ============================================================================
// LabelGenerator Implementation
// ============================================================================

LabelGenerator::LabelGenerator() = default;

std::string LabelGenerator::generateLabel(const std::string &prefix) {
    return prefix + std::to_string(nextLabelIndex++);
}

void LabelGenerator::reset() {
    nextLabelIndex = 1;
}

// ============================================================================
// CodeGenerator Implementation
// ============================================================================

std::string CodeGenerator::generate(const Program *program) {
    output.clear();
    output.str("");

    // Check for main function
    bool hasMainFunction = false;
    for (const auto &statement : program->statements) {
        if (statement->nodeType == NodeType::FUNCTION_DECLARATION) {
            const auto *funcDecl =
                dynamic_cast<const FunctionDeclaration *>(statement.get());
            if (funcDecl->name == "main") {
                // Check if iter returns int
                if (funcDecl->returnType->nodeType == NodeType::BASIC_TYPE) {
                    const auto *returnType = dynamic_cast<const BasicType *>(
                        funcDecl->returnType.get());
                    if (returnType->baseType == TokenType::INT) {
                        hasMainFunction = true;
                        // Get the actual label for main (might be namespace
                        // qualified)
                        if (semanticAnalyzer != nullptr) {
                            Symbol *symbol =
                                semanticAnalyzer->getSymbolTable().findSymbol(
                                    "main");
                        }
                        break;
                    }
                }
            }
        }
    }

    if (!hasMainFunction) {
        throw CodeGeneratorError("Entry Point fn int main() not found!");
    }

    emitComment("Generated by C-Alpha Compiler");
    emitComment("Target: Alpha_TUI Assembly");
    emit("");

    // Generate code for all statements
    for (const auto &statement : program->statements) {
        generateStatement(statement.get());
    }

    // Get the highest memory address used after all code generation
    int highestAddress = memoryManager.getNextMemoryAddress() - 1;

    // Convert the output to a string
    std::string generatedCode = output.str();

    // find line that ONLY contains "main:"
    size_t mainLabelPos = generatedCode.find("\nglobal::main:\n");
    if (mainLabelPos == std::string::npos) {
        throw CodeGeneratorError(
            "Main function label not found in generated code");
    }

    size_t maxAddress = memoryManager.getNextMemoryAddress() - 1;

    generatedCode.insert(mainLabelPos + 15,
                         "\n p(0) := " + std::to_string(maxAddress) +
                             " // Highest memory address used: " +
                             std::to_string(maxAddress) + "\n");

    generatedCode.replace(mainLabelPos, 15, "main:          ");

    // Replace all global with ""
    size_t pos = 0;
    while ((pos = generatedCode.find("global::", pos)) != std::string::npos) {
        generatedCode.replace(pos, 8, "");
        pos += 1; // Move past the newly replaced character
    }

    // Replace all :: with __
    pos = 0;
    while ((pos = generatedCode.find("::", pos)) != std::string::npos) {
        generatedCode.replace(pos, 2, "_");
        pos += 1; // Move past the newly replaced character
    }

    semanticAnalyzer->printSymbolTable();

    // Add program termination
    generatedCode += "\n// Program termination\ngoto END\n";

    return generatedCode;
}

void CodeGenerator::reset() {
    output.clear();
    output.str("");
    registerAllocator.clearAll();
    memoryManager.clearAll();
    labelGenerator.reset();
    stackDepth = 0;
    while (!stackComments.empty()) {
        stackComments.pop();
    }
    breakLabels.clear();
    continueLabels.clear();
    currentFunction.clear();
    functionParameterCounts.clear();
    variableLayoutTypes.clear();
}

// Helper methods
void CodeGenerator::emit(const std::string &instruction) {
    output << instruction << '\n';
}

void CodeGenerator::emitComment(const std::string &comment) {
    output << "// " << comment << '\n';
}

void CodeGenerator::emitLabel(const std::string &label) {
    output << label << ":" << '\n';
}

// ============================================================================
// Stack Operations
// ============================================================================

void CodeGenerator::pushToStack(const std::string &comment) {
    emit("push" + (comment.empty() ? "" : " // " + comment));
    stackDepth++;
    emitComment("DEBUG: Stack depth after push: " + std::to_string(stackDepth));
    if (!comment.empty()) {
        stackComments.push(comment);
    }
}

void CodeGenerator::popFromStack(const std::string &comment) {
    if (stackDepth <= 0) {
        emitComment("WARNING: Stack underflow detected - stackDepth: " +
                    std::to_string(stackDepth));
        // Temporarily disable the exception to see if the program works
        // throw CodeGeneratorError("Stack underflow: trying to pop from empty
        // stack");
    }
    emit("pop" + (comment.empty() ? "" : " // " + comment));
    stackDepth--;
    emitComment("DEBUG: Stack depth after pop: " + std::to_string(stackDepth));
    if (!stackComments.empty()) {
        stackComments.pop();
    }
}

void CodeGenerator::emitStackOperation(const std::string &operation,
                                       const std::string &comment) {
    // Stack operations like stack+, stack-, stack*, stack/, stack% consume 2
    // values and push 1 result Net effect is -1 on stack depth
    emit(operation + (comment.empty() ? "" : " // " + comment));
    stackDepth--;
    emitComment("DEBUG: Stack depth after " + operation + ": " +
                std::to_string(stackDepth));
}

void CodeGenerator::pushRegisterToStack(int registerIndex,
                                        const std::string &comment) {
    std::string regName = registerAllocator.getRegisterName(registerIndex);
    emit("push " + regName + (comment.empty() ? "" : " // " + comment));
    stackDepth++;
    if (!comment.empty()) {
        stackComments.push(comment);
    }
}

void CodeGenerator::popStackToRegister(int registerIndex,
                                       const std::string &comment) {
    if (stackDepth <= 0) {
        throw CodeGeneratorError("Stack underflow: trying to pop to register");
    }
    std::string regName = registerAllocator.getRegisterName(registerIndex);
    emit("pop " + regName + (comment.empty() ? "" : " // " + comment));
    stackDepth--;
    if (!stackComments.empty()) {
        stackComments.pop();
    }
}

// ============================================================================
// Memory Operations
// ============================================================================

// FQDN Helper Methods
std::string CodeGenerator::getVariableFQDN(const std::string &name) {
    Symbol *symbol = semanticAnalyzer->getSymbolTable().findSymbol(name);
    if (symbol == nullptr) {
        emitComment("DEBUG: Variable " + name + " not found in symbol table");
        return name; // Fallback to simple name if not found
    }
    return symbol->fqdn;
}

std::string CodeGenerator::getLayoutFQDN(const std::string &name) {
    Symbol *symbol = semanticAnalyzer->getSymbolTable().findSymbol(name);
    if ((symbol == nullptr) || symbol->symbolKind != SymbolKind::LAYOUT) {
        emitComment("DEBUG: Layout " + name + " not found in symbol table");
        return name; // Fallback to simple name if not found
    }
    return symbol->fqdn;
}

void CodeGenerator::trackVariableLayout(const std::string &varFQDN,
                                        const std::string &layoutFQDN) {
    variableLayoutTypes[varFQDN] = layoutFQDN;
    emitComment("DEBUG: Tracking variable " + varFQDN + " as layout type " +
                layoutFQDN);
}

std::string CodeGenerator::getVariableLayoutType(const std::string &varFQDN) {
    // Find the variable's symbol using its FQDN
    Symbol *sym = semanticAnalyzer->getSymbolTable().findSymbolByFQDN(varFQDN);
    if (sym == nullptr) {
        emitComment("DEBUG: Variable " + varFQDN +
                    " not found in symbol table");
        return "";
    }

    std::cout << "CRIT: " << sym->toString() << '\n';

    // Retrieve the type of the variable
    if (sym->type) {
        if (sym->type->kind == SemanticTypeKind::LAYOUT) {
            // If the type is a layout, return the layout's FQDN
            const auto *lst =
                dynamic_cast<const LayoutSemanticType *>(sym->type.get());
            std::cout << "[CRIT 2]" << lst->toString() << '\n';
            std::string layoutName = lst->layoutName;
            if (!layoutName.empty()) {
                emitComment("DEBUG: Found layout type " + layoutName +
                            " for variable " + varFQDN);
                trackVariableLayout(varFQDN, layoutName);
                return layoutName;
            }
        } else if (sym->type->kind == SemanticTypeKind::POINTER) {
            // Handle pointer types - check if they point to layout types
            const auto *ptrType =
                dynamic_cast<const PointerSemanticType *>(sym->type.get());
            if (ptrType && ptrType->pointsTo && ptrType->pointsTo->kind == SemanticTypeKind::LAYOUT) {
                const auto *lst =
                    dynamic_cast<const LayoutSemanticType *>(ptrType->pointsTo.get());
                std::cout << "[CRIT 3] Pointer to layout: " << lst->toString() << '\n';
                std::string layoutName = lst->layoutName;
                if (!layoutName.empty()) {
                    emitComment("DEBUG: Found pointer to layout type " + layoutName +
                                " for variable " + varFQDN);
                    trackVariableLayout(varFQDN, layoutName);
                    return layoutName;
                }
            }
        }
    }

    emitComment("DEBUG: No layout type found for variable " + varFQDN);
    return "";
}

// Memory Operations with FQDN support
void CodeGenerator::loadFromMemory(int registerIndex,
                                   const std::string &varFQDN) {
    int address = memoryManager.getVariableAddress(varFQDN);
    emit("a" + std::to_string(registerIndex) + " := p(" +
         std::to_string(address) + ") // Load " + varFQDN);
}

void CodeGenerator::storeToMemory(const std::string &varFQDN,
                                  int registerIndex) {
    int address = memoryManager.getVariableAddress(varFQDN);
    emit("p(" + std::to_string(address) + ") := a" +
         std::to_string(registerIndex) + " // Store " + varFQDN);
}

void CodeGenerator::loadFromMemoryToStack(const std::string &varFQDN,
                                          const std::string &comment) {
    int address = memoryManager.getVariableAddress(varFQDN);
    emit("a0 := p(" + std::to_string(address) + ") // Load " + varFQDN);
    pushToStack(comment.empty() ? "Load " + varFQDN : comment);
}

void CodeGenerator::storeFromStackToMemory(const std::string &varFQDN,
                                           const std::string &comment) {
    int address = memoryManager.getVariableAddress(varFQDN);
    popFromStack(comment.empty() ? "Store " + varFQDN : comment);
    emit("p(" + std::to_string(address) + ") := a0 // Store " + varFQDN);
}

// ============================================================================
// Statement Generation
// ============================================================================

void CodeGenerator::generateStatement(const Statement *stmt) {
    if (stmt == nullptr)
        return;

    switch (stmt->nodeType) {
    case NodeType::NAMESPACE_DECLARATION:
        generateNamespaceDeclaration(
            dynamic_cast<const NamespaceDeclaration *>(stmt));
        break;
    case NodeType::VARIABLE_DECLARATION:
        generateVariableDeclaration(
            dynamic_cast<const VariableDeclaration *>(stmt));
        break;
    case NodeType::ASSIGNMENT:
        generateAssignment(dynamic_cast<const Assignment *>(stmt));
        break;
    case NodeType::FUNCTION_DECLARATION:
        generateFunctionDeclaration(
            dynamic_cast<const FunctionDeclaration *>(stmt));
        break;
    case NodeType::RETURN_STATEMENT:
        generateReturnStatement(dynamic_cast<const ReturnStatement *>(stmt));
        break;
    case NodeType::IF_STATEMENT:
        generateIfStatement(dynamic_cast<const IfStatement *>(stmt));
        break;
    case NodeType::WHILE_STATEMENT:
        generateWhileStatement(dynamic_cast<const WhileStatement *>(stmt));
        break;
    case NodeType::BLOCK_STATEMENT:
        generateBlockStatement(dynamic_cast<const BlockStatement *>(stmt));
        break;
    case NodeType::EXPRESSION_STATEMENT:
        generateExpressionStatement(
            dynamic_cast<const ExpressionStatement *>(stmt));
        break;
    case NodeType::LAYOUT_DECLARATION:
        generateLayoutDeclaration(
            dynamic_cast<const LayoutDeclaration *>(stmt));
        break;
    default:
        emitComment("Warning: Unhandled statement type");
        break;
    }
}

void CodeGenerator::generateNamespaceDeclaration(
    const NamespaceDeclaration *namespaceDecl) {
    emitComment("Namespace: " + namespaceDecl->name);

    // Push namespace scope
    if (semanticAnalyzer != nullptr)
        semanticAnalyzer->getSymbolTable().pushScope("namespace_" +
                                                     namespaceDecl->name);
    memoryManager.pushScope("namespace_" + namespaceDecl->name);

    // Generate code for all statements in the namespace
    for (const auto &stmt : namespaceDecl->statements) {
        generateStatement(stmt.get());
    }

    // Pop namespace scope
    memoryManager.popScope();
    if (semanticAnalyzer != nullptr)
        semanticAnalyzer->getSymbolTable().popScope();

    emit("");
}

// Update variable declaration to use FQDNs
void CodeGenerator::generateVariableDeclaration(
    const VariableDeclaration *varDecl) {
    std::string varFQDN = getVariableFQDN(varDecl->name);
    std::cout << "Variable declaration: " << varFQDN << '\n';
    // Track layout type if applicable by inspecting the symbol's semantic type
    if (semanticAnalyzer != nullptr) {
        Symbol *varSymbol =
            semanticAnalyzer->getSymbolTable().findSymbolByFQDN(varFQDN);
        std::cout << "Variable symbol: " << varSymbol->name << '\n';
        if ((varSymbol != nullptr) && varSymbol->type) {
            const SemanticType *currentType = varSymbol->type.get();
            // Handle pointers to layouts
            if (currentType->isPointer()) {
                const auto *ptrType =
                    static_cast<const PointerSemanticType *>(currentType);
                currentType = ptrType->pointsTo.get();
            }
            // Check if the base type is a layout
            if (currentType->isLayout()) {
                const auto *layoutType =
                    static_cast<const LayoutSemanticType *>(currentType);
                trackVariableLayout(varFQDN, layoutType->layoutName);
                std::cout << "Layout type: " << layoutType->layoutName << '\n';
                // Get all members of the layout
                for (const auto &member : layoutType->members) {
                    std::cout
                        << "Member FQDN: " << varFQDN + "::" + member->name
                        << '\n';
                    std::cout << "Member: " << member->name << '\n';
                    std::cout << "Member type: " << member->type->toString()
                              << '\n';
                    std::cout << "Invoking memoryManager.allocateMemory("
                              << varFQDN + "::" + member->name << ")" << '\n';
                    memoryManager.allocateMemory(varFQDN + "::" + member->name);
                }
            }
        }
    }

    // Allocate memory
    int address = memoryManager.allocateMemory(varFQDN);

    // Generate initialization code if present
    if (varDecl->initializer) {
        // Check if this is layout initialization
        if (varDecl->initializer->nodeType == NodeType::LAYOUT_INITIALIZATION) {
            const auto *layoutInit = static_cast<const LayoutInitialization *>(varDecl->initializer.get());
            std::string layoutFQDN = getVariableLayoutType(varFQDN);
            
            if (!layoutFQDN.empty()) {
                emitComment("Layout initialization for " + varFQDN + " (layout: " + layoutFQDN + ")");
                
                // Generate code for each initialization value and store it in the corresponding member
                int baseAddress = memoryManager.getVariableAddress(varFQDN);

                // Store base address at base address
                emit("p(" + std::to_string(baseAddress) + ") := " + std::to_string(baseAddress) + " // Store base address for layout " + layoutFQDN);

                // Get layout type information to determine member types
                Symbol *layoutSymbol = semanticAnalyzer->getSymbolTable().findSymbol(layoutFQDN);
                const LayoutSemanticType *layoutType = nullptr;
                if (layoutSymbol && layoutSymbol->symbolKind == SymbolKind::LAYOUT) {
                    layoutType = static_cast<const LayoutSemanticType *>(layoutSymbol->type.get());
                }
                
                int currentOffset = 1; // Start after base address
                for (size_t i = 0; i < layoutInit->values.size(); ++i) {
                    generateExpression(layoutInit->values[i].get());
                    popFromStack("Get layout member value " + std::to_string(i));
                    
                    // Calculate member address: base + accumulated offset
                    int memberAddress = baseAddress + currentOffset;
                    
                    // Check if this member is a layout type
                    bool memberIsLayout = false;
                    if (layoutType && i < layoutType->members.size()) {
                        if (layoutType->members[i]->type->isLayout()) {
                            memberIsLayout = true;
                            const auto *memberLayoutType = static_cast<const LayoutSemanticType *>(layoutType->members[i]->type.get());
                            emitComment("DEBUG: Member " + std::to_string(i) + " is layout type " + memberLayoutType->layoutName);
                            
                            // For layout members, we need to copy the entire layout
                            // The value on stack should be the base address of the source layout
                            emit("a1 := a0 // Source layout base address");
                            
                            // Copy each member of the nested layout from source to destination
                            int memberLayoutSize = calculateLayoutSize(memberLayoutType->layoutName);
                            for (int j = 1; j < memberLayoutSize; ++j) { // Start from 1, skip base address
                                emit("a1 := a0 + " + std::to_string(j) + " // Move to source member ");
                                emit("a2 := p(a1) // Load source member " + std::to_string(j));
                                emit("p(" + std::to_string(memberAddress + j) + ") := a2 // Store nested layout member " + std::to_string(j));
                            }
                            
                            // Store the base address of the nested layout
                            emit("p(" + std::to_string(memberAddress) + ") := " + std::to_string(memberAddress) + " // Store nested layout base");
                            
                            // Update offset to account for nested layout size
                            currentOffset += memberLayoutSize;
                            continue;
                        }
                    }
                    
                    // For primitive members, just store the value
                    emit("p(" + std::to_string(memberAddress) + ") := a0 // Store member " + std::to_string(i));
                    
                    // Update offset for next member
                    currentOffset += 1;
                }
            } else {
                emitComment("Warning: Could not determine layout type for " + varFQDN);
                generateExpression(varDecl->initializer.get());
                storeFromStackToMemory(varFQDN, "Initialize " + varDecl->name);
            }
        } else {
            generateExpression(varDecl->initializer.get());
            storeFromStackToMemory(varFQDN, "Initialize " + varDecl->name);
        }
    }
}

void CodeGenerator::generateAssignment(const Assignment *assignment) {
    emitComment("Assignment");
    
    // Check if this is layout initialization assignment
    if (assignment->value->nodeType == NodeType::LAYOUT_INITIALIZATION &&
        assignment->target->nodeType == NodeType::IDENTIFIER) {
        
        const auto *layoutInit = static_cast<const LayoutInitialization *>(assignment->value.get());
        const auto *id = static_cast<const Identifier *>(assignment->target.get());
        std::string varFQDN = getVariableFQDN(id->name);
        
        // Get the layout type from the target variable
        std::string layoutFQDN = getVariableLayoutType(varFQDN);
        if (!layoutFQDN.empty()) {
            emitComment("Layout initialization assignment for " + varFQDN + " (layout: " + layoutFQDN + ")");
            
            // Generate code for each initialization value and store it in the corresponding member
            int baseAddress = memoryManager.getVariableAddress(varFQDN);
            
            for (size_t i = 0; i < layoutInit->values.size(); ++i) {
                generateExpression(layoutInit->values[i].get());
                popFromStack("Get layout member value " + std::to_string(i));
                
                // Calculate member address: base + member offset
                int memberOffset = i + 1; // Members start at offset 1 (0 is base)
                int memberAddress = baseAddress + memberOffset;
                
                emit("p(" + std::to_string(memberAddress) + ") := a0 // Store member " + std::to_string(i));
            }
            return;
        } else {
            emitComment("Warning: Could not determine layout type for " + varFQDN);
        }
    }
    
    generateExpression(assignment->value.get()); // value on stack

    if (assignment->target->nodeType == NodeType::IDENTIFIER) {
        const auto *id =
            static_cast<const Identifier *>(assignment->target.get());
        std::string varFQDN = getVariableFQDN(id->name);
        storeFromStackToMemory(varFQDN, "Assign to " + id->name);
    } else if (assignment->target->nodeType == NodeType::MEMBER_ACCESS) {
        const auto *memberAccess =
            static_cast<const MemberAccess *>(assignment->target.get());
        emitComment("Member access assignment");

        // Determine the layout type first, then generate the object expression
        std::string layoutFQDN;
        std::string objDescription;
        
        if (memberAccess->object->nodeType == NodeType::IDENTIFIER) {
            const auto *objId = static_cast<const Identifier *>(memberAccess->object.get());
            std::string objFQDN = getVariableFQDN(objId->name);
            layoutFQDN = getVariableLayoutType(objFQDN);
            objDescription = objId->name;
        } else if (memberAccess->object->nodeType == NodeType::ARRAY_ACCESS) {
            // Handle array access - get the array variable and its element type
            const auto *arrayAccess = static_cast<const ArrayAccess *>(memberAccess->object.get());
            
            if (arrayAccess->array->nodeType == NodeType::IDENTIFIER) {
                const auto *arrayId = static_cast<const Identifier *>(arrayAccess->array.get());
                std::string arrayFQDN = getVariableFQDN(arrayId->name);
                
                // Find the array's element type (which should be a layout)
                Symbol *arraySymbol = semanticAnalyzer->getSymbolTable().findSymbolByFQDN(arrayFQDN);
                if (arraySymbol && arraySymbol->type && arraySymbol->type->isPointer()) {
                    const auto *ptrType = static_cast<const PointerSemanticType *>(arraySymbol->type.get());
                    if (ptrType->pointsTo && ptrType->pointsTo->isLayout()) {
                        const auto *layoutType = static_cast<const LayoutSemanticType *>(ptrType->pointsTo.get());
                        layoutFQDN = layoutType->layoutName;
                        objDescription = arrayId->name + "[" + arrayAccess->index->toString() + "]";
                    }
                }
            }
        } else if (memberAccess->object->nodeType == NodeType::MEMBER_ACCESS) {
            // Handle chained member access like n.tuple.right
            const auto *nestedMemberAccess = static_cast<const MemberAccess *>(memberAccess->object.get());
            
            // Get the layout type by tracing through the chain
            if (nestedMemberAccess->object->nodeType == NodeType::IDENTIFIER) {
                const auto *baseId = static_cast<const Identifier *>(nestedMemberAccess->object.get());
                std::string baseFQDN = getVariableFQDN(baseId->name);
                std::string baseLayoutFQDN = getVariableLayoutType(baseFQDN);
                
                if (!baseLayoutFQDN.empty()) {
                    // Find the type of the nested member
                    Symbol *baseLayoutSymbol = semanticAnalyzer->getSymbolTable().findSymbol(baseLayoutFQDN);
                    if (baseLayoutSymbol && baseLayoutSymbol->symbolKind == SymbolKind::LAYOUT) {
                        const auto *baseLayoutType = static_cast<const LayoutSemanticType *>(baseLayoutSymbol->type.get());
                        for (const auto &member : baseLayoutType->members) {
                            if (member->name == nestedMemberAccess->memberName && member->type->isLayout()) {
                                const auto *memberLayoutType = static_cast<const LayoutSemanticType *>(member->type.get());
                                layoutFQDN = memberLayoutType->layoutName;
                                objDescription = baseId->name + "." + nestedMemberAccess->memberName;
                                emitComment("DEBUG: Chained member access: " + objDescription + " has layout type " + layoutFQDN);
                                break;
                            }
                        }
                    }
                }
            }
        } else if (memberAccess->object->nodeType == NodeType::UNARY_EXPRESSION) {
            // Handle dereference operations like (<-b.ptr).value
            const auto *unaryExpr = static_cast<const UnaryExpression *>(memberAccess->object.get());
            
            if (unaryExpr->operator_ == TokenType::DEREFERENCE) {
                emitComment("DEBUG: Assignment - handling dereference in member access");
                
                // The operand of dereference should give us a pointer to a layout
                if (unaryExpr->operand->nodeType == NodeType::MEMBER_ACCESS) {
                    // Case: (<-b.ptr).value where b.ptr is a pointer to layout
                    const auto *ptrMemberAccess = static_cast<const MemberAccess *>(unaryExpr->operand.get());
                    
                    if (ptrMemberAccess->object->nodeType == NodeType::IDENTIFIER) {
                        const auto *baseId = static_cast<const Identifier *>(ptrMemberAccess->object.get());
                        std::string baseFQDN = getVariableFQDN(baseId->name);
                        std::string baseLayoutFQDN = getVariableLayoutType(baseFQDN);
                        
                        emitComment("DEBUG: Assignment - analyzing dereference of member access " + baseId->name + "." + ptrMemberAccess->memberName);
                        emitComment("DEBUG: Assignment - base object " + baseId->name + " has layout type " + baseLayoutFQDN);
                        
                        if (!baseLayoutFQDN.empty()) {
                            // Find the type of the pointer member
                            Symbol *baseLayoutSymbol = semanticAnalyzer->getSymbolTable().findSymbol(baseLayoutFQDN);
                            if (baseLayoutSymbol && baseLayoutSymbol->symbolKind == SymbolKind::LAYOUT) {
                                const auto *baseLayoutType = static_cast<const LayoutSemanticType *>(baseLayoutSymbol->type.get());
                                for (const auto &member : baseLayoutType->members) {
                                    if (member->name == ptrMemberAccess->memberName) {
                                        emitComment("DEBUG: Assignment - found member " + member->name + " with type " + member->type->toString());
                                        if (member->type->isPointer()) {
                                            const auto *ptrType = static_cast<const PointerSemanticType *>(member->type.get());
                                            if (ptrType->pointsTo && ptrType->pointsTo->isLayout()) {
                                                const auto *pointedLayoutType = static_cast<const LayoutSemanticType *>(ptrType->pointsTo.get());
                                                layoutFQDN = pointedLayoutType->layoutName;
                                                objDescription = "(<-" + baseId->name + "." + ptrMemberAccess->memberName + ")";
                                                emitComment("DEBUG: Assignment - dereference member access: " + objDescription + " has layout type " + layoutFQDN);
                                            } else {
                                                emitComment("DEBUG: Assignment - pointer member " + ptrMemberAccess->memberName + " does not point to a layout");
                                            }
                                        } else {
                                            emitComment("DEBUG: Assignment - member " + ptrMemberAccess->memberName + " is not a pointer type");
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                    }
                } else if (unaryExpr->operand->nodeType == NodeType::IDENTIFIER) {
                    // Case: (<-ptr).member where ptr is a pointer to layout
                    const auto *ptrId = static_cast<const Identifier *>(unaryExpr->operand.get());
                    std::string ptrFQDN = getVariableFQDN(ptrId->name);
                    
                    // Find the variable's type to see what it points to
                    Symbol *ptrSymbol = semanticAnalyzer->getSymbolTable().findSymbolByFQDN(ptrFQDN);
                    if (ptrSymbol && ptrSymbol->type && ptrSymbol->type->isPointer()) {
                        const auto *ptrType = static_cast<const PointerSemanticType *>(ptrSymbol->type.get());
                        if (ptrType->pointsTo && ptrType->pointsTo->isLayout()) {
                            const auto *pointedLayoutType = static_cast<const LayoutSemanticType *>(ptrType->pointsTo.get());
                            layoutFQDN = pointedLayoutType->layoutName;
                            objDescription = "(<-" + ptrId->name + ")";
                            emitComment("DEBUG: Assignment - direct pointer dereference: " + objDescription + " has layout type " + layoutFQDN);
                        }
                    }
                }
            }
        } else {
            objDescription = memberAccess->object->toString();
        }

        if (!layoutFQDN.empty()) {
            int memberOffset = 0;
            bool found = false;
            
            try {
                memberOffset = memoryManager.getLayoutMemberOffset(
                    layoutFQDN, memberAccess->memberName);
                found = true;
                emitComment("DEBUG: Found member " + memberAccess->memberName + 
                           " in layout " + layoutFQDN + " at offset " + 
                           std::to_string(memberOffset));
            } catch (const std::exception &) {
                emitComment("ERROR: Member " + memberAccess->memberName +
                           " not found in layout " + layoutFQDN);
            }

            if (!found) {
                emitComment("Warning: Using default offset 0 for member assignment " +
                           memberAccess->memberName + " (layout: " + layoutFQDN + ")");
            }

            // Current stack: assignment value

            // Todo: first set a0 to the object base address
            generateExpression(memberAccess->object.get()); // object base address on stack

            // Calculate member address: object base address + member offset
            popFromStack("Get object base address"); // â†’ Error stackunderflow
            emit("a1 := a0 + " + std::to_string(memberOffset) + 
                 " // Calculate member address (" + objDescription + "." + 
                 memberAccess->memberName + ")");
            
            popFromStack("Get assignment value");
            emit("p(a1) := a0 // Store value in member " + memberAccess->memberName);
        } else {
            emitComment("Warning: Could not determine layout type for " + objDescription);
            popFromStack("Discard object address");
            popFromStack("Discard assignment value");
        }
    } else if (assignment->target->nodeType == NodeType::ARRAY_ACCESS) {
        // Existing array access assignment logic remains unchanged
        const auto *arrayAccess =
            static_cast<const ArrayAccess *>(assignment->target.get());
        emitComment("Array access assignment");
        generateExpression(arrayAccess->array.get());
        generateExpression(arrayAccess->index.get());
        popFromStack("Get index");
        emit("a1 := a0 // Store index in a1");
        popFromStack("Get array base address");
        emit("a2 := a0 + a1 // Calculate element address (base + index)");
        popFromStack("Get assignment value");
        emit("p(a2) := a0 // Store value in array element");
    }

    emit("");
}

void CodeGenerator::generateExpressionStatement(
    const ExpressionStatement *exprStmt) {
    emitComment("Expression statement");
    generateExpression(exprStmt->expression.get());
    // Pop the result since iter's not used
    popFromStack("Discard expression result");
    emit("");
}

void CodeGenerator::generateLayoutDeclaration(
    const LayoutDeclaration *layoutDecl) {
    emitComment("Layout declaration: " + layoutDecl->name);
    emitComment("DEBUG: Processing layout declaration for " + layoutDecl->name);
    setupLayoutMembers(layoutDecl->name, layoutDecl->members);
    emit("");
}

// ============================================================================
// Expression Generation (Basic Framework)
// ============================================================================

void CodeGenerator::generateExpression(const Expression *expr) {
    if (expr == nullptr)
        return;

    switch (expr->nodeType) {
    case NodeType::LITERAL:
        generateLiteral(dynamic_cast<const Literal *>(expr));
        break;
    case NodeType::STRING_LITERAL:
        generateStringLiteral(dynamic_cast<const StringLiteral *>(expr));
        break;
    case NodeType::IDENTIFIER:
        generateIdentifier(dynamic_cast<const Identifier *>(expr));
        break;
    case NodeType::BINARY_EXPRESSION:
        generateBinaryExpression(dynamic_cast<const BinaryExpression *>(expr));
        break;
    case NodeType::UNARY_EXPRESSION:
        generateUnaryExpression(dynamic_cast<const UnaryExpression *>(expr));
        break;
    case NodeType::FUNCTION_CALL:
        generateFunctionCall(dynamic_cast<const FunctionCall *>(expr));
        break;
    case NodeType::MEMBER_ACCESS:
        generateMemberAccess(dynamic_cast<const MemberAccess *>(expr));
        break;
    case NodeType::ARRAY_ACCESS:
        generateArrayAccess(dynamic_cast<const ArrayAccess *>(expr));
        break;
    case NodeType::ARRAY_ALLOCATION:
        generateArrayAllocation(dynamic_cast<const ArrayAllocation *>(expr));
        break;
    case NodeType::SYSCALL_EXPRESSION:
        generateSyscallExpression(
            dynamic_cast<const SyscallExpression *>(expr));
        break;
    case NodeType::TYPE_CAST:
        generateTypeCast(dynamic_cast<const TypeCast *>(expr));
        break;
    case NodeType::LAYOUT_INITIALIZATION:
        generateLayoutInitialization(dynamic_cast<const LayoutInitialization *>(expr));
        break;
    default:
        emitComment("Warning: Unhandled expression type");
        emit("a0 := 0");
        pushToStack("Default value for unhandled expression");
        break;
    }
}

void CodeGenerator::generateTypeCast(const TypeCast *typeCast) {
    emitComment("Type cast");

    // Generate the expression to be cast
    generateExpression(typeCast->expression.get());

    // Get source and target types
    const Type *targetType = typeCast->targetType.get();
    const Expression *sourceExpr = typeCast->expression.get();

    // For now, we only handle basic types
    if (targetType->nodeType == NodeType::BASIC_TYPE) {
        const auto *basicTargetType =
            static_cast<const BasicType *>(targetType);

        // No actual conversion needed for int to char or char to int
        // Just emit a warning if casting between different sizes
        if (basicTargetType->baseType == TokenType::CHAR) {
            emitComment("Warning: Possible data loss when casting to char");
            // Use BITWISE_AND with 255 to mask to char size
            emit("a0 := 255 // Load mask for char size");
            pushToStack("Mask to stack");
            emit(
                "call namespace_bit_BITWISE_AND // Mask to char size (8 bits)");
            pushToStack(
                "cast result"); // Use pushToStack to properly track stack depth
        } else {
            // For int, we don't need to do anything special
            // The value is already the right size
            emitComment("Cast to int (no conversion needed)");
        }
    } else if (targetType->nodeType == NodeType::POINTER_TYPE) {
        emitComment("Raw pointer cast (no conversion needed)");
    } else {
        emitComment("Warning: Unsupported type cast");
    }
}

void CodeGenerator::generateLiteral(const Literal *literal) {
    std::string value = literal->value;
    if (literal->literalType == TokenType::CHARACTER) {
        // Convert character to ASCII value
        if (!value.empty()) {
            char c = value[0];
            int asciiValue = static_cast<int>(static_cast<unsigned char>(c));
            emit("a0 := " + std::to_string(asciiValue));
            pushToStack("Character literal");
        } else {
            // Empty character literal, default to 0
            emit("a0 := 0");
            pushToStack("Empty character literal");
        }
    } else {
        emit("a0 := " + value);
        pushToStack("Literal value" + literal->value);
    }
}

void CodeGenerator::generateStringLiteral(const StringLiteral *stringLit) {
    std::string value = stringLit->value;
    int stringLength = value.length();

    // emitComment("String literal: \"" + stringLit->value + "\"");

    // Allocate memory for the string as a character array + null terminator
    int baseAddress = memoryManager.allocateArray(stringLength + 1);

    // Initialize each character in the array
    for (int i = 0; i < stringLength; i++) {
        char c = value[i];
        int asciiValue = static_cast<int>(
            static_cast<unsigned char>(c)); // Handle negative char values

        // Create a readable comment for the character
        std::string charComment;
        switch (c) {
        case '\n':
            charComment = "\\n";
            break;
        case '\t':
            charComment = "\\t";
            break;
        case '\r':
            charComment = "\\r";
            break;
        case '\0':
            charComment = "\\0";
            break;
        case '\\':
            charComment = "\\\\";
            break;
        case '"':
            charComment = "\\\"";
            break;
        default:
            if (c >= 32 && c <= 126) { // Printable ASCII characters
                charComment = "'" + std::string(1, c) + "'";
            } else {
                charComment = "ASCII " + std::to_string(asciiValue);
            }
            break;
        }

        emit("p(" + std::to_string(baseAddress + i) +
             ") := " + std::to_string(asciiValue) + " // <char alloc>");
    }

    // Add null terminator at the end
    emit("p(" + std::to_string(baseAddress + stringLength) +
         ") := 0 // Null terminator");

    // Push the base address of the string array onto the stack
    emit("a0 := " + std::to_string(baseAddress) +
         " // Base address of string array");
    pushToStack(" string array address");
}

void CodeGenerator::generateIdentifier(const Identifier *id) {
    std::string varFQDN = getVariableFQDN(id->name);
    if (memoryManager.hasVariable(varFQDN)) {
        int address = memoryManager.getVariableAddress(varFQDN);
        emitComment("DEBUG: Loading variable " + varFQDN + " from address " +
                    std::to_string(address));
        
        // Check if this is a layout variable
        std::string layoutFQDN = getVariableLayoutType(varFQDN);
        if (!layoutFQDN.empty()) {
            // For layout variables, return the base address (stored at the address)
            emit("a0 := p(" + std::to_string(address) + ") // Load layout base address for " + id->name);
            emitComment("DEBUG: Variable " + id->name + " is layout type " + layoutFQDN);
        } else {
            // For primitive variables, load the value
            emit("a0 := p(" + std::to_string(address) + ") // Load " + id->name);
        }
        
        pushToStack(" variable " + id->name);
    } else {
        emitComment("WARNING: Undefined variable " + varFQDN + " - using 0");
        emit("a0 := 0");
        pushToStack(" undefined variable " + id->name);
    }
}

void CodeGenerator::generateBinaryExpression(const BinaryExpression *binExpr) {
    // Generate left operand (will be on stack)
    generateExpression(binExpr->left.get());

    // Generate right operand (will be on stack)
    generateExpression(binExpr->right.get());

    // Handle comparison operations differently
    if (isComparisonOperator(binExpr->operator_)) {
        // Pop both operands to registers
        popFromStack("Get right operand");
        emit("a1 := a0");
        popFromStack("Get left operand");

        // Generate comparison result directly
        generateComparisonResult(binExpr->operator_);

        // Result is already pushed by generateComparisonResult
    }
    // Handle bitwise operations
    else if (binExpr->operator_ == TokenType::BITWISE_AND ||
             binExpr->operator_ == TokenType::BITWISE_OR ||
             binExpr->operator_ == TokenType::BITWISE_XOR) {
        // Pop operands into registers
        // a0 now has left operand, a1 has right operand

        switch (binExpr->operator_) {
        case TokenType::BITWISE_AND:
            emit("call namespace_bit_BITWISE_AND // Perform bitwise AND");
            break;
        case TokenType::BITWISE_OR:
            emit("call namespace_bit_BITWISE_OR // Perform bitwise OR");
            break;
        case TokenType::BITWISE_XOR:
            emit("call namespace_bit_BITWISE_XOR // Perform bitwise XOR");
            break;
        default:
            break;
        }

        // Result is now in a0
        pushToStack(" bitwise operation result");
    }
    // Handle regular arithmetic operations
    else {
        std::string op = getOperatorInstruction(binExpr->operator_);
        emit(op + " // Binary operation");
    }
}

void CodeGenerator::generateUnaryExpression(const UnaryExpression *unExpr) {
    emitComment("Unary expression");

    switch (unExpr->operator_) {
    case TokenType::REFERENCE: {
        // Reference operator (->): get address of variable
        if (unExpr->operand->nodeType == NodeType::IDENTIFIER) {
            const auto *id =
                static_cast<const Identifier *>(unExpr->operand.get());
            if (memoryManager.hasVariable(id->name)) {
                int address = memoryManager.getVariableAddress(id->name);
                emit("a0 := " + std::to_string(address) + " // Address of " +
                     id->name);
                pushToStack(" address");
            } else {
                emitComment("Warning: Taking address of undefined variable " +
                            id->name);
                emit("a0 := 0");
                pushToStack(" null address");
            }
        } else {
            emitComment("Warning: Reference operator on non-identifier");
            emit("a0 := 0");
            pushToStack(" null address");
        }
        break;
    }
    case TokenType::DEREFERENCE: {
        // Dereference operator (<-): load value from address
        generateExpression(unExpr->operand.get()); // Get the address
        popFromStack("Get address");
        emit("a0 := p(a0) // Dereference address");
        pushToStack(" dereferenced value");
        break;
    }
    case TokenType::MINUS: {
        // Unary minus: negate value
        generateExpression(unExpr->operand.get());
        popFromStack("Get value");
        emit("a1 := 0");
        emit("a0 := a1 - a0 // Negate value");
        pushToStack(" negated value");
        break;
    }
    case TokenType::BITWISE_NOT: {
        // Bitwise NOT: flip all bits
        generateExpression(unExpr->operand.get());
        popFromStack("Get value");
        emit("a0 := ~a0 // Bitwise NOT");
        pushToStack(" NOT result");
        break;
    }
    default:
        emitComment("Warning: Unsupported unary operator");
        generateExpression(unExpr->operand.get());
        break;
    }
}

void CodeGenerator::generateFunctionCall(const FunctionCall *funcCall) {
    // Check if this is a namespace-qualified function call
    size_t dotPos = funcCall->functionName.find('.');
    std::string actualFunctionName;

    if (dotPos != std::string::npos) {
        std::string namespaceName = funcCall->functionName.substr(0, dotPos);
        std::string functionName = funcCall->functionName.substr(dotPos + 1);

        // Look up the function in the semantic analyzer to get its FQDN
        if (semanticAnalyzer != nullptr) {
            // Push namespace scope to find the function
            auto &symTable = semanticAnalyzer->getSymbolTable();
            symTable.pushScope("namespace_" + namespaceName);
            Symbol *symbol = symTable.findSymbol(functionName);
            symTable.popScope();

            if (symbol != nullptr) {
                actualFunctionName = symbol->fqdn;
            } else {
                // Fallback to old format if symbol not found
                actualFunctionName =
                    "namespace_" + namespaceName + "_" + functionName;
            }
        } else {
            // Fallback to old format if no semantic analyzer
            actualFunctionName =
                "namespace_" + namespaceName + "_" + functionName;
        }
    } else {
        // For non-namespace functions, try to get FQDN from symbol table
        if (semanticAnalyzer != nullptr) {
            Symbol *symbol = semanticAnalyzer->getSymbolTable().findSymbol(
                funcCall->functionName);
            if (symbol != nullptr) {
                actualFunctionName = symbol->fqdn;
            } else {
                actualFunctionName = funcCall->functionName;
            }
        } else {
            actualFunctionName = funcCall->functionName;
        }
    }

    emitComment("Function call: " + funcCall->functionName);

    // Push arguments in reverse order
    int argCount = funcCall->arguments.size();
    emitComment("DEBUG: Pushing " + std::to_string(argCount) + " arguments");

    for (int i = argCount - 1; i >= 0; i--) {
        emitComment("DEBUG: Pushing argument " + std::to_string(i));
        generateExpression(funcCall->arguments[i].get());
    }

    // Call the function using the actual function name
    emit("call " + actualFunctionName + " // Function call");

    // Function call result is already on stack (function pushed iter)
    // No additional stack operations needed
    emitComment("DEBUG: Function call completed - return value is on stack");
}

// Update member access to use FQDNs
void CodeGenerator::generateMemberAccess(const MemberAccess *memberAccess) {
    // Determine layout type BEFORE generating the object expression
    std::string objFQDN;
    std::string layoutFQDN;
    
    if (memberAccess->object->nodeType == NodeType::IDENTIFIER) {
        const auto *objId =
            static_cast<const Identifier *>(memberAccess->object.get());
        objFQDN = getVariableFQDN(objId->name);
        layoutFQDN = getVariableLayoutType(objFQDN);
        emitComment("DEBUG: Simple identifier access: " + objFQDN + " has layout type " + layoutFQDN);
    } else if (memberAccess->object->nodeType == NodeType::ARRAY_ACCESS) {
        // Handle array access - get the array variable and its element type
        const auto *arrayAccess = static_cast<const ArrayAccess *>(memberAccess->object.get());
        
        if (arrayAccess->array->nodeType == NodeType::IDENTIFIER) {
            const auto *arrayId = static_cast<const Identifier *>(arrayAccess->array.get());
            std::string arrayFQDN = getVariableFQDN(arrayId->name);
            
            // Find the array's element type (which should be a layout)
            Symbol *arraySymbol = semanticAnalyzer->getSymbolTable().findSymbolByFQDN(arrayFQDN);
            if (arraySymbol && arraySymbol->type && arraySymbol->type->isPointer()) {
                const auto *ptrType = static_cast<const PointerSemanticType *>(arraySymbol->type.get());
                if (ptrType->pointsTo && ptrType->pointsTo->isLayout()) {
                    const auto *layoutType = static_cast<const LayoutSemanticType *>(ptrType->pointsTo.get());
                    layoutFQDN = layoutType->layoutName;
                    objFQDN = arrayFQDN + "[" + arrayAccess->index->toString() + "]";
                    emitComment("DEBUG: Array element has layout type " + layoutFQDN);
                }
            }
        }
    } else if (memberAccess->object->nodeType == NodeType::MEMBER_ACCESS) {
        // Handle nested member access like n.tuple.right
        const auto *nestedMemberAccess = static_cast<const MemberAccess *>(memberAccess->object.get());
        
        // Get the layout type by tracing through the chain
        if (nestedMemberAccess->object->nodeType == NodeType::IDENTIFIER) {
            const auto *baseId = static_cast<const Identifier *>(nestedMemberAccess->object.get());
            std::string baseFQDN = getVariableFQDN(baseId->name);
            std::string baseLayoutFQDN = getVariableLayoutType(baseFQDN);
            
            if (!baseLayoutFQDN.empty()) {
                // Find the type of the nested member
                Symbol *baseLayoutSymbol = semanticAnalyzer->getSymbolTable().findSymbol(baseLayoutFQDN);
                if (baseLayoutSymbol && baseLayoutSymbol->symbolKind == SymbolKind::LAYOUT) {
                    const auto *baseLayoutType = static_cast<const LayoutSemanticType *>(baseLayoutSymbol->type.get());
                    for (const auto &member : baseLayoutType->members) {
                        if (member->name == nestedMemberAccess->memberName) {
                            if (member->type->isLayout()) {
                                const auto *memberLayoutType = static_cast<const LayoutSemanticType *>(member->type.get());
                                layoutFQDN = memberLayoutType->layoutName;
                                objFQDN = baseId->name + "." + nestedMemberAccess->memberName;
                                emitComment("DEBUG: Chained member access: " + objFQDN + " has layout type " + layoutFQDN);
                            } else {
                                emitComment("DEBUG: Member " + nestedMemberAccess->memberName + " is not a layout type");
                                objFQDN = baseId->name + "." + nestedMemberAccess->memberName;
                            }
                            break;
                        }
                    }
                }
            }
        }
    } else if (memberAccess->object->nodeType == NodeType::UNARY_EXPRESSION) {
        // Handle dereference operations like (<-n.tuple).right
        const auto *unaryExpr = static_cast<const UnaryExpression *>(memberAccess->object.get());
        
        if (unaryExpr->operator_ == TokenType::DEREFERENCE) {
            emitComment("DEBUG: Handling dereference in member access");
            
            // The operand of dereference should give us a pointer to a layout
            if (unaryExpr->operand->nodeType == NodeType::MEMBER_ACCESS) {
                // Case: (<-b.ptr).value where b.ptr is a pointer to layout
                const auto *ptrMemberAccess = static_cast<const MemberAccess *>(unaryExpr->operand.get());
                
                if (ptrMemberAccess->object->nodeType == NodeType::IDENTIFIER) {
                    const auto *baseId = static_cast<const Identifier *>(ptrMemberAccess->object.get());
                    std::string baseFQDN = getVariableFQDN(baseId->name);
                    std::string baseLayoutFQDN = getVariableLayoutType(baseFQDN);
                    
                    emitComment("DEBUG: Analyzing dereference of member access " + baseId->name + "." + ptrMemberAccess->memberName);
                    emitComment("DEBUG: Base object " + baseId->name + " has layout type " + baseLayoutFQDN);
                    
                    if (!baseLayoutFQDN.empty()) {
                        // Find the type of the pointer member
                        Symbol *baseLayoutSymbol = semanticAnalyzer->getSymbolTable().findSymbol(baseLayoutFQDN);
                        if (baseLayoutSymbol && baseLayoutSymbol->symbolKind == SymbolKind::LAYOUT) {
                            const auto *baseLayoutType = static_cast<const LayoutSemanticType *>(baseLayoutSymbol->type.get());
                            for (const auto &member : baseLayoutType->members) {
                                if (member->name == ptrMemberAccess->memberName) {
                                    emitComment("DEBUG: Found member " + member->name + " with type " + member->type->toString());
                                    if (member->type->isPointer()) {
                                        const auto *ptrType = static_cast<const PointerSemanticType *>(member->type.get());
                                        if (ptrType->pointsTo && ptrType->pointsTo->isLayout()) {
                                            const auto *pointedLayoutType = static_cast<const LayoutSemanticType *>(ptrType->pointsTo.get());
                                            layoutFQDN = pointedLayoutType->layoutName;
                                            objFQDN = "(<-" + baseId->name + "." + ptrMemberAccess->memberName + ")";
                                            emitComment("DEBUG: Dereference member access: " + objFQDN + " has layout type " + layoutFQDN);
                                        } else {
                                            emitComment("DEBUG: Pointer member " + ptrMemberAccess->memberName + " does not point to a layout");
                                        }
                                    } else {
                                        emitComment("DEBUG: Member " + ptrMemberAccess->memberName + " is not a pointer type");
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            } else if (unaryExpr->operand->nodeType == NodeType::IDENTIFIER) {
                // Case: (<-ptr).member where ptr is a pointer to layout
                const auto *ptrId = static_cast<const Identifier *>(unaryExpr->operand.get());
                std::string ptrFQDN = getVariableFQDN(ptrId->name);
                
                // Find the variable's type to see what it points to
                Symbol *ptrSymbol = semanticAnalyzer->getSymbolTable().findSymbolByFQDN(ptrFQDN);
                if (ptrSymbol && ptrSymbol->type && ptrSymbol->type->isPointer()) {
                    const auto *ptrType = static_cast<const PointerSemanticType *>(ptrSymbol->type.get());
                    if (ptrType->pointsTo && ptrType->pointsTo->isLayout()) {
                        const auto *pointedLayoutType = static_cast<const LayoutSemanticType *>(ptrType->pointsTo.get());
                        layoutFQDN = pointedLayoutType->layoutName;
                        objFQDN = "(<-" + ptrId->name + ")";
                        emitComment("DEBUG: Direct pointer dereference: " + objFQDN + " has layout type " + layoutFQDN);
                    }
                }
            }
        }
    } else {
        objFQDN = memberAccess->object->toString();
    }

    // Generate code for the object expression (its value ends up on stack)
    generateExpression(memberAccess->object.get());

    if (layoutFQDN.empty()) {
        emitComment("DEBUG: Layout type not found for " + objFQDN);
        return;
    }

    // Process each member access recursively
    const MemberAccess *currentAccess = memberAccess;
    int offset = 0;

    try {
        offset = memoryManager.getLayoutMemberOffset(layoutFQDN,
                                                     currentAccess->memberName);
        emitComment("DEBUG: Found member " + currentAccess->memberName +
                    " in layout " + layoutFQDN + " at offset " +
                    std::to_string(offset));
    } catch (const std::exception &e) {
        emitComment("Warning: Using default offset 0 for member access " +
                    currentAccess->memberName + " (layout: " + layoutFQDN +
                    ")");
        std::cout << "Using default offset 0 for member access "
                  << currentAccess->memberName << " (layout: " << layoutFQDN
                  << ", object: " + objFQDN + ")" << '\n';
        std::cout << "Exception: " << e.what() << '\n';
    }

    // Add total offset to base address
    popFromStack("Get base address");
    emit("a0 := a0 + " + std::to_string(offset) +
         " // Add total member offset");
    
    // Check if this member is itself a layout type
    bool memberIsLayout = false;
    if (!layoutFQDN.empty()) {
        // Look up the layout to get member information
        Symbol *layoutSymbol = semanticAnalyzer->getSymbolTable().findSymbol(layoutFQDN);
        if (layoutSymbol && layoutSymbol->symbolKind == SymbolKind::LAYOUT) {
            const auto *layoutType = static_cast<const LayoutSemanticType *>(layoutSymbol->type.get());
            for (const auto &member : layoutType->members) {
                if (member->name == currentAccess->memberName) {
                    if (member->type->isLayout()) {
                        memberIsLayout = true;
                        emitComment("DEBUG: Member " + member->name + " is a layout type");
                    }
                    break;
                }
            }
        }
    }
    
    if (memberIsLayout) {
        // For layout members, return the address (base address of the nested layout)
        pushToStack(" layout member address");
    } else {
        // For primitive members, load the value
        emit("a0 := p(a0) // Load member value");
        pushToStack(" member value");
    }
}

void CodeGenerator::generateArrayAccess(const ArrayAccess *arrayAccess) {
    emitComment("Array access");

    // Generate the array base address
    generateExpression(arrayAccess->array.get());

    // Generate the index
    generateExpression(arrayAccess->index.get());

    // Determine the element size based on the array's element type
    int elementSize = 1; // Default for basic types
    std::string arrayFQDN;
    
    // Get the array variable's FQDN to determine its element type
    if (arrayAccess->array->nodeType == NodeType::IDENTIFIER) {
        const auto *arrayId = static_cast<const Identifier *>(arrayAccess->array.get());
        arrayFQDN = getVariableFQDN(arrayId->name);
        
        // Find the array's type to determine element size
        Symbol *arraySymbol = semanticAnalyzer->getSymbolTable().findSymbolByFQDN(arrayFQDN);
        if (arraySymbol && arraySymbol->type && arraySymbol->type->isPointer()) {
            const auto *ptrType = static_cast<const PointerSemanticType *>(arraySymbol->type.get());
            if (ptrType->pointsTo && ptrType->pointsTo->isLayout()) {
                const auto *layoutType = static_cast<const LayoutSemanticType *>(ptrType->pointsTo.get());
                elementSize = calculateLayoutSize(layoutType->layoutName);
                emitComment("DEBUG: Array access for layout type " + layoutType->layoutName + 
                           " with element size " + std::to_string(elementSize));
            }
        }
    }

    // Pop index and array address, calculate address
    popFromStack("Get index");
    emit("a1 := a0 // Store index in a1");
    popFromStack("Get array base address");
    
    if (elementSize > 1) {
        // For layout types, multiply index by element size
        emit("a2 := " + std::to_string(elementSize) + " // Element size");
        emit("a1 := a1 * a2 // Calculate offset (index * element_size)");
        emit("a0 := a0 + a1 // Calculate element address (base + offset)");
        emitComment("DEBUG: Layout array access: base + (index * " + std::to_string(elementSize) + ")");
    } else {
        // For basic types, simple addition
        emit("a0 := a0 + a1 // Calculate element address (base + index)");
    }
    
    // For layout types, we return the address (not the value)
    // For basic types, we load the value
    if (elementSize > 1) {
        // Return the address of the layout element (no dereference)
        pushToStack(" layout element address");
    } else {
        // Load the value for basic types
        emit("a0 := p(a0) // Load array element");
        pushToStack(" element value");
    }
}

void CodeGenerator::generateArrayAllocation(const ArrayAllocation *arrayAlloc) {
    emitComment("Array allocation");

    // Generate the size expression
    generateExpression(arrayAlloc->size.get());

    // Pop size to register
    popFromStack("Get array size");
    emit("a1 := a0 // Store size in a1");

    // Calculate the size of each element
    int elementSize = 1; // Default for basic types
    std::string elementLayoutFQDN;
    
    // Check if this is a layout type
    if (arrayAlloc->elementType->nodeType == NodeType::LAYOUT_TYPE) {
        const auto *layoutType = static_cast<const LayoutType *>(arrayAlloc->elementType.get());
        elementLayoutFQDN = getLayoutFQDN(layoutType->layoutName);
        elementSize = calculateLayoutSize(layoutType->layoutName);
        emitComment("DEBUG: Array of layout type " + elementLayoutFQDN + " with element size " + std::to_string(elementSize));
    }

    // For now, allocate array at compile time with a fixed size if iter's a
    // literal
    if (arrayAlloc->size->nodeType == NodeType::LITERAL) {
        const auto *sizeLit =
            static_cast<const Literal *>(arrayAlloc->size.get());
        int arraySize = std::stoi(sizeLit->value);

        // Calculate total memory needed: array size * element size
        int totalMemoryNeeded = arraySize * elementSize;
        emitComment("DEBUG: Allocating array of " + std::to_string(arraySize) + 
                   " elements, each " + std::to_string(elementSize) + 
                   " cells, total " + std::to_string(totalMemoryNeeded) + " cells");

        // Allocate contiguous memory block for the array
        int baseAddress = memoryManager.allocateArray(totalMemoryNeeded);

        emit("a0 := " + std::to_string(baseAddress) +
             " // Base address of allocated array");

        // Initialize array elements
        if (!elementLayoutFQDN.empty()) {
            // For layout types, initialize each element properly
            for (int i = 0; i < arraySize; i++) {
                int elementBaseAddress = baseAddress + (i * elementSize);
                emitComment("DEBUG: Initializing layout element " + std::to_string(i) + 
                           " at address " + std::to_string(elementBaseAddress));
                
                // Initialize layout members to 0
                for (int j = 0; j < elementSize; j++) {
                    emit("p(" + std::to_string(elementBaseAddress + j) +
                         ") := 0 // Initialize layout member " + std::to_string(j));
                }
            }
        } else {
            // Simple initialization for basic types
            for (int i = 0; i < totalMemoryNeeded; i++) {
                emit("p(" + std::to_string(baseAddress + i) +
                     ") := 0 // Initialize element " + std::to_string(i));
            }
        }
    } else {
        // Dynamic allocation - for now, use a simple approach
        // This would need runtime memory management in a complete
        // implementation
        int baseAddress =
            memoryManager.allocateArray(100 * elementSize); // Default max size for now
        emit("a0 := " + std::to_string(baseAddress) +
             " // Base address of allocated array (dynamic)");
        emitComment("Warning: Dynamic array allocation simplified");
    }

    pushToStack(" array base address");
}

// ============================================================================
// Utility Methods
// ============================================================================

std::string CodeGenerator::getOperatorInstruction(TokenType op) {
    switch (op) {
    case TokenType::PLUS:
        return "stack+";
    case TokenType::MINUS:
        return "stack-";
    case TokenType::MULTIPLY:
        return "stack*";
    case TokenType::DIVIDE:
        return "stack/";
    case TokenType::MODULO:
        return "stack%";
    case TokenType::BITWISE_AND:
        // Special handling for bitwise AND - don't return an instruction
        return "";
    case TokenType::BITWISE_OR:
        // Special handling for bitwise OR - don't return an instruction
        return "";
    case TokenType::BITWISE_XOR:
        // Special handling for bitwise XOR - don't return an instruction
        return "";
    default:
        return "nop // Unknown operator";
    }
}

bool CodeGenerator::isComparisonOperator(TokenType op) {
    return op == TokenType::EQUAL || op == TokenType::NOT_EQUAL ||
           op == TokenType::LESS_THAN || op == TokenType::LESS_EQUAL ||
           op == TokenType::GREATER_THAN || op == TokenType::GREATER_EQUAL;
}

// ============================================================================
// Helper Methods for Layout Management
// ============================================================================

void CodeGenerator::setupLayoutMembers(
    const std::string &layoutName,
    const std::vector<std::unique_ptr<LayoutMember>> &members) {
    emitComment("DEBUG: Setting up layout '" + layoutName + "' with " +
                std::to_string(members.size()) + " members");

    // Get the fully qualified layout name
    std::string layoutFQDN = layoutName;
    if (semanticAnalyzer != nullptr) {
        Symbol *layoutSymbol =
            semanticAnalyzer->getSymbolTable().findSymbol(layoutName);
        if (layoutSymbol == nullptr) {
            // Try finding by FQDN
            layoutSymbol =
                semanticAnalyzer->getSymbolTable().findSymbolByFQDN(layoutName);
        }
        if (layoutSymbol != nullptr) {
            layoutFQDN = layoutSymbol->fqdn;
            emitComment("DEBUG: Found layout symbol with FQDN: " + layoutFQDN);
        }
    }

    // Extract namespace from layout FQDN if present
    std::string namespaceName;
    size_t lastScopePos = layoutFQDN.rfind("::");
    if (lastScopePos != std::string::npos) {
        namespaceName = layoutFQDN.substr(0, lastScopePos);
        emitComment("DEBUG: Layout is in namespace: " + namespaceName);
    }

    int offset = 1; // 0 = layout base address

    for (const auto &member : members) {
        emitComment("DEBUG: Layout " + layoutFQDN + " member '" + member->name +
                    "' at offset " + std::to_string(offset));
        memoryManager.setLayoutMemberOffset(layoutFQDN, member->name, offset);
        
        // Calculate member size - if it's a layout type, it takes more space
        int memberSize = 1; // Default for primitive types
        if (member->type->nodeType == NodeType::LAYOUT_TYPE) {
            const auto *layoutType = static_cast<const LayoutType *>(member->type.get());
            memberSize = calculateLayoutSize(layoutType->layoutName);
            emitComment("DEBUG: Member " + member->name + " is layout type with size " + std::to_string(memberSize));
        }
        
        offset += memberSize;
    }
}

int CodeGenerator::calculateLayoutSize(const std::string &layoutName) {
    // Look up the layout in semantic analyzer to get member count
    if (semanticAnalyzer != nullptr) {
        Symbol *layoutSymbol =
            semanticAnalyzer->getSymbolTable().findSymbol(layoutName);
        if ((layoutSymbol != nullptr) &&
            layoutSymbol->symbolKind == SymbolKind::LAYOUT) {
            const auto *layoutType = static_cast<const LayoutSemanticType *>(
                layoutSymbol->type.get());
            
            if (layoutType->members.empty())
                return 1; // Even empty layouts need at least 1 cell for base address
            
            // Calculate total size by summing member sizes
            int totalSize = 1; // +1 for the layout base address
            
            for (const auto &member : layoutType->members) {
                if (member->type->isLayout()) {
                    // Recursive calculation for nested layouts
                    const auto *memberLayoutType = static_cast<const LayoutSemanticType *>(member->type.get());
                    totalSize += calculateLayoutSize(memberLayoutType->layoutName);
                } else {
                    // Primitive type takes 1 cell
                    totalSize += 1;
                }
            }
            
            return totalSize;
        }
    }
    return 1; // Default size if layout not found
}

// ============================================================================
// Helper to extract layout name from a Type (handles nested pointers)
// ============================================================================

std::string CodeGenerator::extractLayoutName(const Type *astType) const {
    if (astType == nullptr)
        return "";
    const Type *current = astType;
    while (current != nullptr) {
        if (current->nodeType == NodeType::LAYOUT_TYPE) {
            const auto *lt = static_cast<const LayoutType *>(current);
            std::string layoutName = lt->layoutName;

            // NEW: Resolve to fully-qualified name if a semantic analyzer is
            // available
            if (semanticAnalyzer != nullptr) {
                // First try regular lookup (takes current scope into account)
                Symbol *sym =
                    semanticAnalyzer->getSymbolTable().findSymbol(layoutName);
                if (sym == nullptr) {
                    // If that fails, try treating the provided name as an FQDN
                    sym = semanticAnalyzer->getSymbolTable().findSymbolByFQDN(
                        layoutName);
                }
                if ((sym != nullptr) && sym->symbolKind == SymbolKind::LAYOUT) {
                    layoutName = sym->fqdn; // Use canonical FQDN
                }
            }
            return layoutName;
        }
        if (current->nodeType == NodeType::POINTER_TYPE) {
            const auto *pt = static_cast<const PointerType *>(current);
            current = pt->pointsTo.get();
            continue;
        }
        break;
    }
    return "";
}

// ============================================================================
// Control Flow Methods (Stubs)
// ============================================================================

void CodeGenerator::generateIfStatement(const IfStatement *ifStmt) {
    emitComment("If statement");

    // Generate labels
    std::string elseLabel = labelGenerator.generateLabel("else");
    std::string endLabel = labelGenerator.generateLabel("endif");

    // Generate condition
    generateExpression(ifStmt->condition.get());

    // Pop condition result to register and compare with 0
    popFromStack("Get condition result");

    emit("a1 := 0");
    emit("if a0 == a1 then goto " + elseLabel +
         " // Jump to else if condition is false");

    // Generate then branch
    generateStatement(ifStmt->thenStatement.get());
    emit("goto " + endLabel + " // Jump to end");

    // Generate else branch
    emitLabel(elseLabel);
    if (ifStmt->elseStatement) {
        generateStatement(ifStmt->elseStatement.get());
    }

    emitLabel(endLabel);
    emit("");
}

void CodeGenerator::generateWhileStatement(const WhileStatement *whileStmt) {
    emitComment("While statement");

    // Generate labels
    std::string loopLabel = labelGenerator.generateLabel("loop");
    std::string endLabel = labelGenerator.generateLabel("endloop");

    // Add break/continue labels for nested loops
    breakLabels.push_back(endLabel);
    continueLabels.push_back(loopLabel);

    // Loop start
    emitLabel(loopLabel);

    // Generate condition
    generateExpression(whileStmt->condition.get());

    // Pop condition result to register and compare with 0
    popFromStack("Get condition result");
    emit("a1 := 0");
    emit("if a0 == a1 then goto " + endLabel +
         " // Jump to end if condition is false");

    // Generate loop body
    generateStatement(whileStmt->body.get());

    // Jump back to loop start
    emit("goto " + loopLabel + " // Jump back to loop start");

    // Loop end
    emitLabel(endLabel);

    // Remove break/continue labels
    breakLabels.pop_back();
    continueLabels.pop_back();

    emit("");
}

void CodeGenerator::generateReturnStatement(const ReturnStatement *retStmt) {
    emitComment("Return statement");

    if (retStmt->value) {
        // Generate return value
        generateExpression(retStmt->value.get());
        // Value is already on stack, ready for return
    } else {
        // No return value, push default (0)
        emit("a0 := 0");
        pushToStack("Default return value");
    }

    emit("return // Return from function");
}

void CodeGenerator::generateFunctionDeclaration(
    const FunctionDeclaration *funcDecl) {
    emitComment("Function declaration: " + funcDecl->name);

    // Save current function context
    std::string oldFunction = currentFunction;
    currentFunction = funcDecl->name;

    // Store parameter count for later use
    functionParameterCounts[funcDecl->name] = funcDecl->parameters.size();

    // Generate function label
    emit("");

    // Check if we're in a namespace scope by looking up the function's symbol
    std::string functionLabel = funcDecl->name;
    if (semanticAnalyzer != nullptr) {
        Symbol *symbol =
            semanticAnalyzer->getSymbolTable().findSymbol(funcDecl->name);
        if (symbol != nullptr) {
            functionLabel = symbol->fqdn;
        }
    } else {
        std::cout << "Warning: No semantic analyzer available, using raw "
                     "function name."
                  << '\n';
    }

    emitLabel(functionLabel);

    // Reset stack depth for new function - we'll track iter locally
    stackDepth = funcDecl->parameters.size();
    emitComment("DEBUG: Function " + funcDecl->name +
                " starts with stack depth: " + std::to_string(stackDepth));

    // Push new scope for function parameters and local variables
    if (semanticAnalyzer != nullptr)
        semanticAnalyzer->getSymbolTable().pushScope("function_" +
                                                     funcDecl->name);
    memoryManager.pushScope("function_" + funcDecl->name);

    // Save current variable type tracking and start fresh for this function
    std::unordered_map<std::string, std::string> oldVariableLayoutTypes =
        variableLayoutTypes;
    variableLayoutTypes.clear();

    // Allocate memory for parameters (they come from stack)
    for (const auto &param : funcDecl->parameters) {
        std::string paramFQDN = getVariableFQDN(param->name);
        std::string paramLayout = extractLayoutName(param->type.get());
        if (!paramLayout.empty()) {
            trackVariableLayout(paramFQDN, paramLayout);
        }

        int address = memoryManager.allocateMemory(paramFQDN);

        popFromStack("Get parameter " + param->name);
        emit("p(" + std::to_string(address) + ") := a0 // Store parameter " +
             param->name);
        emitComment("DEBUG: Parameter " + param->name + " stored at address " +
                    std::to_string(address));
    }

    // Generate function body
    generateStatement(funcDecl->body.get());

    // Note: Functions should have explicit return statements
    // If no explicit return is found, the assembler will handle iter
    // Todo: only emit this if no "ret" was found
    emitComment("Function " + funcDecl->name + " ends without explicit return");

    // Restore previous context
    currentFunction = oldFunction;
    variableLayoutTypes = oldVariableLayoutTypes;

    // Pop function scope
    memoryManager.popScope();
    if (semanticAnalyzer != nullptr)
        semanticAnalyzer->getSymbolTable().popScope();
}

void CodeGenerator::generateBlockStatement(const BlockStatement *blockStmt) {
    // Push new scope
    if (semanticAnalyzer != nullptr)
        semanticAnalyzer->getSymbolTable().pushScope("block");
    memoryManager.pushScope("block_" + std::to_string(blockStmt->line) + "_" +
                            std::to_string(blockStmt->column));

    // Generate code for each statement in the block
    for (const auto &statement : blockStmt->statements) {
        generateStatement(statement.get());
    }

    // Pop scope
    memoryManager.popScope();
    if (semanticAnalyzer != nullptr)
        semanticAnalyzer->getSymbolTable().popScope();
}

void CodeGenerator::generateComparison(TokenType op,
                                       const std::string &trueLabel,
                                       const std::string &falseLabel) {
    // Generate conditional jump based on comparison operator
    switch (op) {
    case TokenType::EQUAL:
        emit("if a0 == a1 then goto " + trueLabel + " // Jump if equal");
        break;
    case TokenType::NOT_EQUAL:
        emit("if a0 != a1 then goto " + trueLabel + " // Jump if not equal");
        break;
    case TokenType::LESS_THAN:
        emit("if a0 < a1 then goto " + trueLabel + " // Jump if less than");
        break;
    case TokenType::LESS_EQUAL:
        emit("if a0 <= a1 then goto " + trueLabel +
             " // Jump if less than or equal");
        break;
    case TokenType::GREATER_THAN:
        emit("if a0 > a1 then goto " + trueLabel + " // Jump if greater than");
        break;
    case TokenType::GREATER_EQUAL:
        emit("if a0 >= a1 then goto " + trueLabel +
             " // Jump if greater than or equal");
        break;
    default:
        emitComment("Unknown comparison operator");
        break;
    }
    emit("goto " + falseLabel + " // Jump to false branch");
}

void CodeGenerator::generateComparisonResult(TokenType op) {
    // Generate result (1 for true, 0 for false) based on comparison
    std::string trueLabel = labelGenerator.generateLabel("true");
    std::string endLabel = labelGenerator.generateLabel("cmp_end");

    switch (op) {
    case TokenType::EQUAL:
        emit("if a0 == a1 then goto " + trueLabel + " // Jump if equal");
        break;
    case TokenType::NOT_EQUAL:
        emit("if a0 != a1 then goto " + trueLabel + " // Jump if not equal");
        break;
    case TokenType::LESS_THAN:
        emit("if a0 < a1 then goto " + trueLabel + " // Jump if less than");
        break;
    case TokenType::LESS_EQUAL:
        emit("if a0 <= a1 then goto " + trueLabel +
             " // Jump if less than or equal");
        break;
    case TokenType::GREATER_THAN:
        emit("if a0 > a1 then goto " + trueLabel + " // Jump if greater than");
        break;
    case TokenType::GREATER_EQUAL:
        emit("if a0 >= a1 then goto " + trueLabel +
             " // Jump if greater than or equal");
        break;
    default:
        emitComment("Unknown comparison operator");
        break;
    }

    // False case
    emit("a0 := 0 // Comparison result: false");
    emit("goto " + endLabel);

    // True case
    emitLabel(trueLabel);
    emit("a0 := 1 // Comparison result: true");

    emitLabel(endLabel);

    // Push the comparison result onto the stack
    pushToStack(" comparison result");
}

void CodeGenerator::generateSyscallExpression(
    const SyscallExpression *syscallExpr) {
    emitComment("Syscall expression");

    // Generate each argument and assign to registers a0-a6
    for (size_t i = 0; i < syscallExpr->arguments.size(); ++i) {
        generateExpression(syscallExpr->arguments[i].get());
        popFromStack("Get argument " + std::to_string(i));
        if (i == 0)
            pushToStack(" syscall number");

        emit("a" + std::to_string(i) + " := a0 // Store argument " +
             std::to_string(i) + " in register a" + std::to_string(i));
    }

    popFromStack("Get syscall number");

    // Execute syscall
    emit("syscall // Execute system call");

    // Syscall result is in a0, push iter to stack
    pushToStack(" syscall result");
}

void CodeGenerator::generateLayoutInitialization(const LayoutInitialization *layoutInit) {
    emitComment("Layout initialization expression");
    
    // Layout initialization expressions need to be handled in context
    // (i.e., during assignment or variable declaration) to know the target layout type.
    // For now, we'll just push the values onto the stack in reverse order
    // so they can be retrieved during assignment/declaration.
    
    emitComment("DEBUG: Layout initialization with " + std::to_string(layoutInit->values.size()) + " values");
    
    // Push values in reverse order (so first value is on top)
    for (int i = static_cast<int>(layoutInit->values.size()) - 1; i >= 0; i--) {
        generateExpression(layoutInit->values[i].get());
        emitComment("DEBUG: Pushed initialization value " + std::to_string(i));
    }
    
    // Push a marker to indicate this is a layout initialization
    emit("a0 := " + std::to_string(layoutInit->values.size()) + " // Number of layout init values");
    pushToStack(" layout init marker");
}

} // namespace calpha